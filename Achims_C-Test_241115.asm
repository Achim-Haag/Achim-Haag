; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34433.0 

	TITLE	C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_word_is_allowed
PUBLIC	_is_character_unmarked
PUBLIC	_update_state
PUBLIC	_get_input
PUBLIC	_print_result
PUBLIC	_another_round
PUBLIC	_main
EXTRN	_isprint:PROC
EXTRN	_tolower:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__SetConsoleMode@8:PROC
EXTRN	_abort:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_getopt:PROC
EXTRN	_getchar:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__time64:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_optind:DWORD
EXTRN	_optopt:DWORD
EXTRN	_optarg:DWORD
EXTRN	_words:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_verbolvl DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG75308 DB	'word_is_allowed', 00H
$SG75309 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75311 DB	'word_is_allowed', 00H
$SG75312 DB	09H, '#DBG %s@%d # strncmp [%s] with [%s]', 0aH, 00H
	ORG $+2
$SG75315 DB	'word_is_allowed', 00H
$SG75316 DB	09H, '#DBG %s@%d # found word %s', 0aH, 00H
	ORG $+3
$SG75318 DB	'true', 00H
	ORG $+3
$SG75319 DB	'false', 00H
	ORG $+2
$SG75320 DB	'word_is_allowed', 00H
$SG75321 DB	09H, '#DBG %s@%d # Returning with ''%s''', 0aH, 00H
	ORG $+1
$SG75332 DB	'is_character_unmarked', 00H
	ORG $+2
$SG75333 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75351 DB	'update_state', 00H
	ORG $+3
$SG75352 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75371 DB	'get_input', 00H
	ORG $+2
$SG75372 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75373 DB	0aH, '%d. trial (#=exit) : ', 00H
	ORG $+1
$SG75378 DB	'get_input', 00H
	ORG $+2
$SG75379 DB	09H, '#DBG %s@%d # Input: [%s]', 0aH, 00H
	ORG $+1
$SG75382 DB	'Please enter exactly (!) %d characters !', 0aH, 00H
	ORG $+2
$SG75384 DB	'get_input', 00H
	ORG $+2
$SG75385 DB	09H, '#DBG %s@%d # Back from word_is_allowed', 0aH, 00H
	ORG $+3
$SG75388 DB	'Word not found in my wordlist', 0aH, 00H
	ORG $+1
$SG75389 DB	'Word found in my wordlist', 0aH, 00H
	ORG $+1
$SG75391 DB	'true', 00H
	ORG $+3
$SG75392 DB	'false', 00H
	ORG $+2
$SG75393 DB	'get_input', 00H
	ORG $+2
$SG75394 DB	09H, '#DBG %s@%d # badword is  %s', 0aH, 00H
	ORG $+2
$SG75396 DB	'get_input', 00H
	ORG $+2
$SG75397 DB	09H, '#DBG %s@%d # Leaving function', 0aH, 00H
$SG75408 DB	'print_result', 00H
	ORG $+3
$SG75409 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75410 DB	'! ', 00H
	ORG $+1
$SG75412 DB	01bH, '[37;42;1m', 00H
	ORG $+1
$SG75414 DB	01bH, '[37;43;1m', 00H
	ORG $+1
$SG75417 DB	01bH, '[37;41;1m', 00H
	ORG $+1
$SG75418 DB	'%c', 00H
	ORG $+1
$SG75419 DB	01bH, '[0m', 0aH, 00H
	ORG $+2
$SG75429 DB	'another_round', 00H
	ORG $+2
$SG75430 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75431 DB	'Another round ? [j/n] ', 00H
	ORG $+1
$SG75434 DB	0aH, 'OK, now go ahead...', 0aH, 00H
	ORG $+2
$SG75480 DB	'14:46:17', 00H
	ORG $+3
$SG75481 DB	'Dec  7 2024', 00H
$SG75482 DB	'***** Running %s,', 0aH, 'Binary build date: %s @ %s ***'
	DB	'**', 0aH, 0aH, 00H
	ORG $+3
$SG75483 DB	0aH, 'Part %d : process commandline parameters by getopt.'
	DB	'c', 0aH, 00H
	ORG $+1
$SG75484 DB	'hf:v:c', 00H
	ORG $+5
$SG75486 DB	'Sample C programm derived from c''t wordle', 0aH, 'typed'
	DB	' in and modified by Achim Haag,', 0aH, 'see https://github.co'
	DB	'm/Achim-Haag/My_First_C_Program/blob/main/.vscode/tasks.json', 0aH
	DB	'derived from c''t 25/2024 (8.11.24), page 66 (https://github.'
	DB	'com/607011/wordle-c)', 0aH, 'Allowed commandline parameters:', 0aH
	DB	'-h : this help', 0aH, '-v <verbosity-level> : debugging', 0aH
	DB	'-f <number> : constant random number sequence for debugging', 0aH
	DB	'-c : show the word to guess in advance (just for debugging ;-'
	DB	')', 00H
	ORG $+3
$SG75488 DB	'Verbosity set to %s', 0aH, 00H
	ORG $+3
$SG75489 DB	'verbosity = %d (from string [%s])', 0aH, 00H
	ORG $+1
$SG75492 DB	'Verbosity level allowed from 1...9. Bye !', 0aH, 00H
	ORG $+1
$SG75494 DB	'Random generater value from parameter is %s', 00H
	ORG $+4
$SG75495 DB	'Random generator value set to fixed number %d ... you''r'
	DB	'e debugging or a cheater ?!?', 0aH, 00H
	ORG $+3
$SG75497 DB	'Cheating the word is enabled (%d)', 0aH, 00H
	ORG $+1
$SG75501 DB	'Option -%c requires an argument. Try -h !', 0aH, 00H
	ORG $+1
$SG75504 DB	'Unknown option `-%c''. Try -h !', 0aH, 00H
$SG75505 DB	'Unknown option character `\x%x'', try -h ! Bye', 0aH, 00H
	ORG $+1
$SG75507 DB	'Parameter %c not handled, contact programmer !', 00H
	ORG $+1
$SG75509 DB	'main', 00H
	ORG $+3
$SG75510 DB	09H, '#DBG %s@%d # Unprocessed commmandline parameters (%'
	DB	'd parameters):', 0aH, 00H
$SG75511 DB	'main', 00H
	ORG $+3
$SG75512 DB	09H, '#DBG %s@%d # Non-option argument [%s]', 0aH, 00H
$SG75513 DB	0aH, 'Part %d : enable ANSI colors in windows terminal', 0aH
	DB	00H
	ORG $+1
$SG75515 DB	'Cannot get handle for standard device (STD_OUTPUT_HANDLE'
	DB	'), GetStdHandle RC=%d', 00H
	ORG $+2
$SG75517 DB	'Cannot get console mode, GetConsoleMode RC=%d', 00H
	ORG $+2
$SG75519 DB	'Cannot set console mode to virt. terminal proc., SetCons'
	DB	'oleMode RC=%d', 00H
	ORG $+2
$SG75520 DB	0aH, 'Part %d :  Now the quiz, here we go...', 0aH, 00H
	ORG $+3
$SG75522 DB	'Initial random generator seed: %d', 0aH, 00H
	ORG $+1
$SG75523 DB	0aH, 'NERD WORD', 0aH, 0aH, 'Guess the word with %d chara'
	DB	'cters in no more than %d trials.', 0aH, '(Abort = Ctrl+C - or'
	DB	' simply the hash key ''#'')', 0aH, 00H
$SG75525 DB	'true', 00H
	ORG $+3
$SG75526 DB	'false', 00H
	ORG $+2
$SG75527 DB	'main', 00H
	ORG $+3
$SG75528 DB	09H, '#DBG %s@%d # Entering while-loop, keepRunning is %s'
	DB	0aH, 00H
	ORG $+2
$SG75530 DB	'main', 00H
	ORG $+3
$SG75531 DB	09H, '#DBG %s@%d # Calling game_state', 0aH, 00H
	ORG $+2
$SG75533 DB	'main', 00H
	ORG $+3
$SG75534 DB	09H, '#DBG %s@%d # Table word count is %d', 0aH, 00H
	ORG $+2
$SG75536 DB	'main', 00H
	ORG $+3
$SG75537 DB	09H, '#DBG %s@%d # Hint: you''re guessing for [%s]', 0aH, 00H
	ORG $+2
$SG75539 DB	'main', 00H
	ORG $+3
$SG75540 DB	09H, '#DBG %s@%d # Entering for-loop, state.n_tries is %d'
	DB	0aH, 00H
	ORG $+2
$SG75542 DB	'main', 00H
	ORG $+3
$SG75543 DB	09H, '#DBG %s@%d # Calling get_input', 0aH, 00H
	ORG $+3
$SG75547 DB	'main', 00H
	ORG $+3
$SG75548 DB	09H, '#DBG %s@%d # Calling update_state', 0aH, 00H
$SG75551 DB	0aH, 'Yee-haw, you''ve won after %d. trials!', 0aH, 00H
$SG75553 DB	'You don''t guess the word, it was %s.', 0aH, 00H
	ORG $+2
$SG75555 DB	'main', 00H
	ORG $+3
$SG75556 DB	09H, '#DBG %s@%d # keepRunning after get_input', 0aH, 00H
	ORG $+1
$SG75558 DB	'true', 00H
	ORG $+3
$SG75559 DB	'false', 00H
	ORG $+2
$SG75560 DB	'main', 00H
	ORG $+3
$SG75561 DB	09H, '#DBG %s@%d # Bottom of while-loop, keepRunning is %'
	DB	's', 0aH, 00H
	ORG $+1
$SG75562 DB	0aH, 'Waiting for you pressing -Enter- (or do something w'
	DB	'ith WinDBG ;-)', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	064fH
voltbl	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_opterr$ = -112						; size = 4
_endkey$ = -108						; size = 4
tv311 = -104						; size = 4
tv209 = -100						; size = 4
_seed$ = -96						; size = 4
tv195 = -92						; size = 4
_hOut$ = -88						; size = 4
_fixrandomseed$ = -84					; size = 4
_dwMode$ = -80						; size = 4
_index$1 = -76						; size = 4
_cmdline_arg$ = -72					; size = 4
_verbosity$ = -68					; size = 4
tv77 = -64						; size = 4
_num_words$2 = -60					; size = 4
_LastError$ = -56					; size = 4
_doRestart$3 = -51					; size = 1
_cheatword$ = -50					; size = 1
_keepRunning$ = -49					; size = 1
_state$4 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 401  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 402  : 
; 403  : 
; 404  : /*
; 405  :   To be sure, I run the least compiled .exe:
; 406  :   #pragma message: print filename (source) and  compile/build date/time while compiling/building and
; 407  :   printf : print filename (.exe) and  compile/build date/time when running
; 408  : */
; 409  : #pragma message ("***** Build " __FILE__ " at " __DATE__ " " __TIME__ "*****\n")   
; 410  :   printf("***** Running %s,\nBinary build date: %s @ %s *****\n\n", argv[0], __DATE__, __TIME__);

	push	OFFSET $SG75480
	push	OFFSET $SG75481
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET $SG75482
	call	_printf
	add	esp, 16					; 00000010H

; 411  : 
; 412  : /*
; 413  :   Process commandline parameters with Windows-specific getopt.c
; 414  :   getopt is a well-known function in the Unix environment and shells to parse argument lists,
; 415  :   see https://en.wikipedia.org/wiki/Getopt 
; 416  :   or https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html (the sample I used here)
; 417  :   The "main" function has to be defined with arguments "(int argc, char** argv)" (char** is a pointer to a pointer list)
; 418  : */
; 419  :   printf("\nPart %d : process commandline parameters by getopt.c\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	1
	push	OFFSET $SG75483
	call	_printf
	add	esp, 8

; 420  :   char *verbosity = NULL;   // Parameter "-v <number>", number = 1 : lowest verbosity

	mov	DWORD PTR _verbosity$[ebp], 0

; 421  :   int fixrandomseed = 0;    // Parameter "-f <number>" : init random generater with debugging number (otherwise with time stamp)

	mov	DWORD PTR _fixrandomseed$[ebp], 0

; 422  :   bool cheatword = false;   // Parameter "-c" : show each word to guess in advance

	mov	BYTE PTR _cheatword$[ebp], 0

; 423  : 
; 424  : /*
; 425  :   Variables defined for and by getopt.c (https://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html)
; 426  :   Call : getopt(int argc, char* const *argv, const char* options)
; 427  :   argc = number of parameters in argv,
; 428  :   argv = pointer to pointerlist (i.e. to a pointer array), each pointer in pointerlist points to a commandline parameter
; 429  :   options = string with allowed commandline parameters. Colon after parameter means: parameter must have a following string value
; 430  : */  
; 431  :   int cmdline_arg = 0;      // Returns the next commandline parameter from getopt prefixed by "-", else a value of -1

	mov	DWORD PTR _cmdline_arg$[ebp], 0

; 432  :   int opterr = 0;           // getopt.c behaviour regarding error handling; 0 = silent but return "?" in case of error", not 0 = print msg

	mov	DWORD PTR _opterr$[ebp], 0
$LN2@main:

; 433  :   // int optopt in getopt.h     commandline parameter not specified in third parameter of getopt call, i.e. parameter not allowed
; 434  :   // int optind in getopt.h     set by getopt.c to the index of the next elemnt in argv. At end: points to first unprocessed argv element
; 435  :   // char* optarg in getopt.h   set by getopt.c to the option value behind the processed commandline parameter (e.g. "1" for "-v 1")
; 436  : 
; 437  : /* Now parse the given-to-main commandline parameters */
; 438  : /* Implemented: "-h" = help; "-v <number>" = verbosity with level (1=lowest); -f = fixed random generator value (NULL)*/
; 439  : /* The colon after an option requests a value behind an option character */
; 440  :   while ((cmdline_arg = getopt (argc, argv, "hf:v:c")) != -1) {

	push	OFFSET $SG75484
	mov	ecx, DWORD PTR _argv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argc$[ebp]
	push	edx
	call	_getopt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cmdline_arg$[ebp], eax
	cmp	DWORD PTR _cmdline_arg$[ebp], -1
	je	$LN3@main

; 441  :     // As we don't have here a valid verbolvl, I leave this debugging statement as comment:
; 442  :     // printf("### Entering next getopts loop (while), cmdline_arg = %d = %c\n", cmdline_arg, cmdline_arg);
; 443  :     switch (cmdline_arg) {

	mov	eax, DWORD PTR _cmdline_arg$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	mov	ecx, DWORD PTR tv77[ebp]
	sub	ecx, 63					; 0000003fH
	mov	DWORD PTR tv77[ebp], ecx
	cmp	DWORD PTR tv77[ebp], 55			; 00000037H
	ja	$LN31@main
	mov	edx, DWORD PTR tv77[ebp]
	movzx	eax, BYTE PTR $LN58@main[edx]
	jmp	DWORD PTR $LN59@main[eax*4]
$LN20@main:

; 444  :       case 'h':                     // Option -h -> Help
; 445  :         printf("Sample C programm derived from c't wordle\n"

	push	OFFSET $SG75486
	call	_printf
	add	esp, 4

; 446  :              "typed in and modified by Achim Haag,\n"
; 447  :              "see https://github.com/Achim-Haag/My_First_C_Program/blob/main/.vscode/tasks.json\n"
; 448  :              "derived from c't 25/2024 (8.11.24), page 66 (https://github.com/607011/wordle-c)\n"
; 449  :              "Allowed commandline parameters:\n"
; 450  :              "-h : this help\n"
; 451  :              "-v <verbosity-level> : debugging\n"
; 452  :              "-f <number> : constant random number sequence for debugging\n"
; 453  :              "-c : show the word to guess in advance (just for debugging ;-)");
; 454  :         return 1; // !!! Attention !!! Early return to OS

	mov	eax, 1
	jmp	$LN1@main

; 455  :         break;    // Never reached because of return

	jmp	$LN4@main
$LN21@main:

; 456  :       case 'v':                     // Option -v -> Verbosity, must be followed by a number (level of verbosity)
; 457  :         verbosity = optarg;   // Defined by getopt.h, returned from getopt

	mov	ecx, DWORD PTR _optarg
	mov	DWORD PTR _verbosity$[ebp], ecx

; 458  :         printf("Verbosity set to %s\n", verbosity);

	mov	edx, DWORD PTR _verbosity$[ebp]
	push	edx
	push	OFFSET $SG75488
	call	_printf
	add	esp, 8

; 459  :         // Convert verbosity string to integer
; 460  :         verbolvl=atoi(verbosity);

	mov	eax, DWORD PTR _verbosity$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _verbolvl, eax

; 461  :         printf ("verbosity = %d (from string [%s])\n", verbolvl, verbosity);

	mov	ecx, DWORD PTR _verbosity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _verbolvl
	push	edx
	push	OFFSET $SG75489
	call	_printf
	add	esp, 12					; 0000000cH

; 462  :         if (verbolvl < 1 || verbolvl > 9) {

	cmp	DWORD PTR _verbolvl, 1
	jl	SHORT $LN23@main
	cmp	DWORD PTR _verbolvl, 9
	jle	SHORT $LN22@main
$LN23@main:

; 463  :           printf("Verbosity level allowed from 1...9. Bye !\n");

	push	OFFSET $SG75492
	call	_printf
	add	esp, 4

; 464  :           return 8; // !!! Attention !!! Early return to OS

	mov	eax, 8
	jmp	$LN1@main

; 465  :           break;    // Never reached because of abort

	jmp	$LN4@main
$LN22@main:

; 466  :         }
; 467  :         break;

	jmp	$LN4@main
$LN24@main:

; 468  :       case 'f':                     // Option -f -> Fixed random number
; 469  :         printf("Random generater value from parameter is %s", optarg);

	mov	eax, DWORD PTR _optarg
	push	eax
	push	OFFSET $SG75494
	call	_printf
	add	esp, 8

; 470  :         fixrandomseed=atoi(optarg);

	mov	ecx, DWORD PTR _optarg
	push	ecx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _fixrandomseed$[ebp], eax

; 471  :         printf("Random generator value set to fixed number %d ... you're debugging or a cheater ?!?\n", fixrandomseed);

	mov	edx, DWORD PTR _fixrandomseed$[ebp]
	push	edx
	push	OFFSET $SG75495
	call	_printf
	add	esp, 8

; 472  :         break;

	jmp	$LN4@main
$LN25@main:

; 473  :       case 'c':                     // Option -f -> Fixed random number
; 474  :         cheatword = true;

	mov	BYTE PTR _cheatword$[ebp], 1

; 475  :         printf("Cheating the word is enabled (%d)\n", cheatword);

	movzx	eax, BYTE PTR _cheatword$[ebp]
	push	eax
	push	OFFSET $SG75497
	call	_printf
	add	esp, 8

; 476  :         break;

	jmp	$LN4@main
$LN26@main:

; 477  :       case '?':                     // Any other commandline parameter error
; 478  :         if (optopt == 'v') {         // optopt: Parameter in error, here -v without following number

	cmp	DWORD PTR _optopt, 118			; 00000076H
	jne	SHORT $LN27@main

; 479  :           fprintf (stderr, "Option -%c requires an argument. Try -h !\n", optopt);

	mov	ecx, DWORD PTR _optopt
	push	ecx
	push	OFFSET $SG75501
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@main
$LN27@main:

; 480  :         } else if (isprint (optopt)) {    // here we found a parameter not specified in the third getopt argument (string, see above)

	mov	edx, DWORD PTR _optopt
	push	edx
	call	_isprint
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@main

; 481  :           fprintf (stderr, "Unknown option `-%c'. Try -h !\n", optopt);

	mov	eax, DWORD PTR _optopt
	push	eax
	push	OFFSET $SG75504
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 482  :         } else {                    // Any other getopt error - exit program

	jmp	SHORT $LN30@main
$LN29@main:

; 483  :           fprintf (stderr, "Unknown option character `\\x%x', try -h ! Bye\n", optopt);

	mov	ecx, DWORD PTR _optopt
	push	ecx
	push	OFFSET $SG75505
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN30@main:

; 484  :         } // endif
; 485  :         return 1; // !!! Attention !!! Early return to OS

	mov	eax, 1
	jmp	$LN1@main

; 486  :         break;    // Never reached because of return

	jmp	SHORT $LN4@main
$LN31@main:

; 487  :       default:                      // Parameter allowed but not handled - this should not occur
; 488  :         printf("Parameter %c not handled, contact programmer !", cmdline_arg);

	mov	edx, DWORD PTR _cmdline_arg$[ebp]
	push	edx
	push	OFFSET $SG75507
	call	_printf
	add	esp, 8

; 489  :         abort (); // !!! Attention !!! Early return to OS

	call	_abort
	npad	1
$LN4@main:

; 490  :         break;    // Never reached because of abort
; 491  :     }
; 492  :   }

	jmp	$LN2@main
$LN3@main:

; 493  : 
; 494  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN7@main

; 495  :     printf("\t#DBG %s@%d # Unprocessed commmandline parameters (%d parameters):\n", __func__, __LINE__, optind);

	mov	eax, DWORD PTR _optind
	push	eax
	push	495					; 000001efH
	push	OFFSET $SG75509
	push	OFFSET $SG75510
	call	_printf
	add	esp, 16					; 00000010H

; 496  :     for (int index = optind; index < argc; index++) printf ("\t#DBG %s@%d # Non-option argument [%s]\n", __func__, __LINE__, argv[index]);

	mov	ecx, DWORD PTR _optind
	mov	DWORD PTR _index$1[ebp], ecx
	jmp	SHORT $LN8@main
$LN6@main:
	mov	edx, DWORD PTR _index$1[ebp]
	add	edx, 1
	mov	DWORD PTR _index$1[ebp], edx
$LN8@main:
	mov	eax, DWORD PTR _index$1[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jge	SHORT $LN7@main
	mov	ecx, DWORD PTR _index$1[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	496					; 000001f0H
	push	OFFSET $SG75511
	push	OFFSET $SG75512
	call	_printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@main
$LN7@main:

; 497  :   }
; 498  : 
; 499  : /*
; 500  :   To enable ANSI text formatting in Windows cmd.exe, I had to add some extra code in my environment (W10 22H2)
; 501  :   Stolen from https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-select-anniversary-update-features
; 502  :   Chapter "Samples" - "Example of SGR terminal sequences"
; 503  : */
; 504  : 
; 505  : #if _MSC_VER          // Necessary only in Windows environment as bash should know ANSI by default
; 506  : 
; 507  : /*
; 508  :   Enable Windows 10 cmd.exe ANSI processing
; 509  : */
; 510  :   printf("\nPart %d : enable ANSI colors in windows terminal\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	2
	push	OFFSET $SG75513
	call	_printf
	add	esp, 8

; 511  :   // Set output mode to handle virtual terminal sequences
; 512  :   DWORD LastError = 0;          // Keep GetLastError in own variable to not interfere with printf

	mov	DWORD PTR _LastError$[ebp], 0

; 513  :   HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	mov	DWORD PTR _hOut$[ebp], eax

; 514  :   if (hOut == INVALID_HANDLE_VALUE)   {

	cmp	DWORD PTR _hOut$[ebp], -1
	jne	SHORT $LN33@main

; 515  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 516  :     printf("Cannot get handle for standard device (STD_OUTPUT_HANDLE), GetStdHandle RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75515
	call	_printf
	add	esp, 8

; 517  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN33@main:

; 518  :   }
; 519  : 
; 520  :   DWORD dwMode = 0;

	mov	DWORD PTR _dwMode$[ebp], 0

; 521  :   if (!GetConsoleMode(hOut, &dwMode)) {

	lea	edx, DWORD PTR _dwMode$[ebp]
	push	edx
	mov	eax, DWORD PTR _hOut$[ebp]
	push	eax
	call	DWORD PTR __imp__GetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN34@main

; 522  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 523  :     printf ("Cannot get console mode, GetConsoleMode RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75517
	call	_printf
	add	esp, 8

; 524  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN34@main:

; 525  :   }
; 526  : 
; 527  :   dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;

	mov	edx, DWORD PTR _dwMode$[ebp]
	or	edx, 4
	mov	DWORD PTR _dwMode$[ebp], edx

; 528  :   if (!SetConsoleMode(hOut, dwMode)) {

	mov	eax, DWORD PTR _dwMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOut$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN35@main

; 529  :    LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 530  :     printf("Cannot set console mode to virt. terminal proc., SetConsoleMode RC=%d", LastError);

	mov	edx, DWORD PTR _LastError$[ebp]
	push	edx
	push	OFFSET $SG75519
	call	_printf
	add	esp, 8

; 531  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN35@main:

; 532  :   }
; 533  : 
; 534  : /*    In sample, but unused here
; 535  : 
; 536  :     // Try some Set Graphics Rendition (SGR) terminal escape sequences
; 537  :     wprintf(L"\x1b[31mThis text has a red foreground using SGR.31.\r\n");
; 538  :     wprintf(L"\x1b[1mThis text has a bright (bold) red foreground using SGR.1 to affect the previous color setting.\r\n");
; 539  :     wprintf(L"\x1b[mThis text has returned to default colors using SGR.0 implicitly.\r\n");
; 540  :     wprintf(L"\x1b[34;46mThis text shows the foreground and background change at the same time.\r\n");
; 541  :     wprintf(L"\x1b[0mThis text has returned to default colors using SGR.0 explicitly.\r\n");
; 542  :     wprintf(L"\x1b[31;32;33;34;35;36;101;102;103;104;105;106;107mThis text attempts to apply many colors in the same command. Note the colors are applied from left to right so only the right-most option of foreground cyan (SGR.36) and background bright white (SGR.107) is effective.\r\n");
; 543  :     wprintf(L"\x1b[39mThis text has restored the foreground color only.\r\n");
; 544  :     wprintf(L"\x1b[49mThis text has restored the background color only.\r\n");
; 545  : 
; 546  :     return 0;
; 547  : */
; 548  : 
; 549  : #endif    // End Windows ANSI enabling section 
; 550  : 
; 551  : 
; 552  : /************************* TEST END *************************** */
; 553  : 
; 554  : 
; 555  :   printf("\nPart %d :  Now the quiz, here we go...\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	3
	push	OFFSET $SG75520
	call	_printf
	add	esp, 8

; 556  : 
; 557  : /*
; 558  :     The following "ternary operator" replaces an if/then/else clause.
; 559  :     Question mark is "then", colon is "else".
; 560  :     If the number of parameters given to this program (including argument 1 = Path+Filename of this program)
; 561  :     is greater than 1, an argument is given explicitly and determins the "random seed".
; 562  :     This eases testing as for a specific initial random seed the random generator returns the same series of numbers
; 563  :     If no explicit parameter is specified, the actual timestamp is used for the initialization of the random generater,
; 564  :     leading to nonpredictable random number series.
; 565  : */
; 566  :   unsigned int seed = (fixrandomseed != 0)

	cmp	DWORD PTR _fixrandomseed$[ebp], 0
	je	SHORT $LN52@main
	mov	eax, DWORD PTR _fixrandomseed$[ebp]
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN53@main
$LN52@main:
	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR tv195[ebp], eax
$LN53@main:
	mov	ecx, DWORD PTR tv195[ebp]
	mov	DWORD PTR _seed$[ebp], ecx

; 567  :                       ? (unsigned int)fixrandomseed
; 568  :                       : (unsigned int)time(NULL) ;
; 569  : 
; 570  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN36@main

; 571  :     printf("Initial random generator seed: %d\n", seed);

	mov	edx, DWORD PTR _seed$[ebp]
	push	edx
	push	OFFSET $SG75522
	call	_printf
	add	esp, 8
$LN36@main:

; 572  :   }
; 573  : 
; 574  : /*
; 575  :     Prepare the random number generation for later use of the "rand" function
; 576  : */
; 577  :   srand(seed);

	mov	eax, DWORD PTR _seed$[ebp]
	push	eax
	call	_srand
	add	esp, 4

; 578  : 
; 579  :   printf("\nNERD WORD\n\n"

	push	6
	push	5
	push	OFFSET $SG75523
	call	_printf
	add	esp, 12					; 0000000cH

; 580  :          "Guess the word with %d characters in no more than %d trials.\n"
; 581  :          "(Abort = Ctrl+C - or simply the hash key '#')\n",
; 582  :          WORD_LENGTH, MAX_TRIES);
; 583  : 
; 584  : /*
; 585  :     We run this program until the user aborts.
; 586  :     we cannot see at this moment, how this decision is made, but we know, 
; 587  :     it must made by setting keepRunning to it's logical value "false".
; 588  : */
; 589  :   bool keepRunning = true;

	mov	BYTE PTR _keepRunning$[ebp], 1
$LN9@main:

; 590  :   while (keepRunning) {

	movzx	ecx, BYTE PTR _keepRunning$[ebp]
	test	ecx, ecx
	je	$LN10@main

; 591  : 
; 592  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN37@main

; 593  :       printf("\t#DBG %s@%d # Entering while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	edx, BYTE PTR _keepRunning$[ebp]
	test	edx, edx
	je	SHORT $LN54@main
	mov	DWORD PTR tv209[ebp], OFFSET $SG75525
	jmp	SHORT $LN55@main
$LN54@main:
	mov	DWORD PTR tv209[ebp], OFFSET $SG75526
$LN55@main:
	mov	eax, DWORD PTR tv209[ebp]
	push	eax
	push	593					; 00000251H
	push	OFFSET $SG75527
	push	OFFSET $SG75528
	call	_printf
	add	esp, 16					; 00000010H
$LN37@main:

; 594  :     }
; 595  : 
; 596  : 
; 597  : /*
; 598  :     First of all create a "real instance" of type game_state, it's name is "state"
; 599  :     It's a structure combining multiple elements in storage (here we need our RAM ;-)
; 600  :     The layout of the structure is defined above as a typeset "game_state"
; 601  :     so "game_state" is - from a higher point of view - the same as an integer, character, string, whatever
; 602  :     But...as far as I think, it's no "executable" statement, it just reserves memory in it's scope
; 603  :     (the compiler generates code to allocate RAM)
; 604  :     Btw: scope means here: "main"
; 605  : */
; 606  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN38@main

; 607  :       printf("\t#DBG %s@%d # Calling game_state\n", __func__, __LINE__);

	push	607					; 0000025fH
	push	OFFSET $SG75530
	push	OFFSET $SG75531
	call	_printf
	add	esp, 12					; 0000000cH
$LN38@main:

; 608  :     }
; 609  :     game_state state;
; 610  : 
; 611  : /*
; 612  :     Count all words in the wordlist (until we reach a null pointer element)
; 613  : */
; 614  :     int num_words;
; 615  :     for (num_words = 0; words[num_words] != NULL; num_words++) {};  // One-line loop

	mov	DWORD PTR _num_words$2[ebp], 0
	jmp	SHORT $LN13@main
$LN11@main:
	mov	ecx, DWORD PTR _num_words$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _num_words$2[ebp], ecx
$LN13@main:
	mov	edx, DWORD PTR _num_words$2[ebp]
	cmp	DWORD PTR _words[edx*4], 0
	je	SHORT $LN12@main
	jmp	SHORT $LN11@main
$LN12@main:

; 616  : 
; 617  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN39@main

; 618  :       printf("\t#DBG %s@%d # Table word count is %d\n", __func__, __LINE__, num_words);

	mov	eax, DWORD PTR _num_words$2[ebp]
	push	eax
	push	618					; 0000026aH
	push	OFFSET $SG75533
	push	OFFSET $SG75534
	call	_printf
	add	esp, 16					; 00000010H
$LN39@main:

; 619  :      }
; 620  : 
; 621  : /*
; 622  :     Now we fill one variable - the pointer to the word - with the address of a randomly selected
; 623  :     word of our wordlist (that comes out of words.c which is linked together with this program)
; 624  :     Important: as the word in array "words" is addressed by modulo (%) NUM_WORDS,
; 625  :     NUM_WORDS must not be higher than the real number of words in the array "words",
; 626  :     else something unpredictable would occur
; 627  :     (maybe NUM_WORDS should be defined near "words" if this is possible ?)
; 628  :     Debugging: the other variables in structure "state" are undefined at the first entry into the loop
; 629  : */
; 630  :     state.word = words[rand() % num_words];

	call	_rand
	cdq
	idiv	DWORD PTR _num_words$2[ebp]
	mov	ecx, DWORD PTR _words[edx*4]
	mov	DWORD PTR _state$4[ebp], ecx

; 631  : 
; 632  : /*
; 633  :     only for testing: show me the selected word
; 634  :     #-marked statements are processed by the compilers preprocessor
; 635  :     (personally, I call it precompiler in memoriam to PL/I ;-)
; 636  :     To activate this printf, a compiler option "-D DEBUG" must be given that defines DEBUG (no value needed)
; 637  :     Not to be confused with _DEBUG (underscore !) that is defined by MSVC by the /MTd or /MDd option,
; 638  :     see https://learn.microsoft.com/en-us/cpp/c-runtime-library/debug?view=msvc-170
; 639  :     Changed to my own precompiler variable MYDEBUG for simplicity
; 640  :     Changed from precompiler variable MYDEBUG to commandline parameter -v <verbolvl> (verbolvl=1..9)
; 641  : */
; 642  :     if ( cheatword ) {    // not dependend on debugging but on commandline parameter -c (Cheat ;-)

	movzx	edx, BYTE PTR _cheatword$[ebp]
	test	edx, edx
	je	SHORT $LN40@main

; 643  :       printf("\t#DBG %s@%d # Hint: you're guessing for [%s]\n", __func__, __LINE__, state.word);

	mov	eax, DWORD PTR _state$4[ebp]
	push	eax
	push	643					; 00000283H
	push	OFFSET $SG75536
	push	OFFSET $SG75537
	call	_printf
	add	esp, 16					; 00000010H
$LN40@main:

; 644  :     }
; 645  : 
; 646  : /*
; 647  :   Now we run another loop that asks our guesses of the characters
; 648  :   The for loop counts a number variable from a starting point to an ending point
; 649  :   In the C language, the ending point doesn't has to be dependend on the number variable alone,
; 650  :   it can be extended by other logical expressions
; 651  : */
; 652  :     bool doRestart = false;

	mov	BYTE PTR _doRestart$3[ebp], 0

; 653  :     for (state.n_tries = 1; 

	mov	DWORD PTR _state$4[ebp+40], 1
	jmp	SHORT $LN16@main
$LN14@main:

; 655  :          ++state.n_tries)    {

	mov	ecx, DWORD PTR _state$4[ebp+40]
	add	ecx, 1
	mov	DWORD PTR _state$4[ebp+40], ecx
$LN16@main:

; 654  :          state.n_tries <= MAX_TRIES && !doRestart;

	cmp	DWORD PTR _state$4[ebp+40], 6
	jg	$LN15@main
	movzx	edx, BYTE PTR _doRestart$3[ebp]
	test	edx, edx
	jne	$LN15@main

; 656  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN41@main

; 657  :         printf("\t#DBG %s@%d # Entering for-loop, state.n_tries is %d\n", __func__, __LINE__, state.n_tries);

	mov	eax, DWORD PTR _state$4[ebp+40]
	push	eax
	push	657					; 00000291H
	push	OFFSET $SG75539
	push	OFFSET $SG75540
	call	_printf
	add	esp, 16					; 00000010H
$LN41@main:

; 658  :       }
; 659  :     
; 660  : /*
; 661  :     we call the above defined function to get user's input.
; 662  :     The "&" means: give the address of variable (structure) "state" to this function,
; 663  :     so this function is able to modify this structure - i.e. the structure's variables
; 664  : */   
; 665  : 
; 666  :     // ask user for keyboard input, exit loop if user wants to
; 667  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN42@main

; 668  :         printf("\t#DBG %s@%d # Calling get_input\n", __func__, __LINE__);

	push	668					; 0000029cH
	push	OFFSET $SG75542
	push	OFFSET $SG75543
	call	_printf
	add	esp, 12					; 0000000cH
$LN42@main:

; 669  :       }
; 670  : 
; 671  :       if (get_input(&state)) {

	lea	ecx, DWORD PTR _state$4[ebp]
	push	ecx
	call	_get_input
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	$LN43@main

; 672  :     // process user's input
; 673  :         if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN45@main

; 674  :           printf("\t#DBG %s@%d # Calling update_state\n", __func__, __LINE__);

	push	674					; 000002a2H
	push	OFFSET $SG75547
	push	OFFSET $SG75548
	call	_printf
	add	esp, 12					; 0000000cH
$LN45@main:

; 675  :         }
; 676  :         update_state(&state);

	lea	eax, DWORD PTR _state$4[ebp]
	push	eax
	call	_update_state
	add	esp, 4

; 677  : 
; 678  :       // show results
; 679  :         print_result(&state);

	lea	ecx, DWORD PTR _state$4[ebp]
	push	ecx
	call	_print_result
	add	esp, 4

; 680  : 
; 681  :       // Compare input word with word to guess, if equal, user wins
; 682  :         if (strncmp(state.guess, state.word, WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _state$4[ebp]
	push	edx
	lea	eax, DWORD PTR _state$4[ebp+4]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN46@main

; 683  :           printf ("\nYee-haw, you've won after %d. trials!\n", state.n_tries);

	mov	ecx, DWORD PTR _state$4[ebp+40]
	push	ecx
	push	OFFSET $SG75551
	call	_printf
	add	esp, 8

; 684  :           doRestart = true;

	mov	BYTE PTR _doRestart$3[ebp], 1

; 685  :           keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al

; 686  :         }

	jmp	SHORT $LN48@main
$LN46@main:

; 687  :         else {
; 688  :           if (state.n_tries == MAX_TRIES) {

	cmp	DWORD PTR _state$4[ebp+40], 6
	jne	SHORT $LN48@main

; 689  :             printf("You don't guess the word, it was %s.\n", state.word);

	mov	edx, DWORD PTR _state$4[ebp]
	push	edx
	push	OFFSET $SG75553
	call	_printf
	add	esp, 8

; 690  :             keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al
$LN48@main:

; 691  :           }
; 692  :         }
; 693  :         
; 694  :       }

	jmp	SHORT $LN44@main
$LN43@main:

; 695  :       else {
; 696  :         keepRunning = false;

	mov	BYTE PTR _keepRunning$[ebp], 0

; 697  :         if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN49@main

; 698  :           printf("\t#DBG %s@%d # keepRunning after get_input\n", __func__, __LINE__), keepRunning;

	push	698					; 000002baH
	push	OFFSET $SG75555
	push	OFFSET $SG75556
	call	_printf
	add	esp, 12					; 0000000cH
$LN49@main:

; 699  :         }
; 700  :         break; // for-loop

	jmp	SHORT $LN15@main
$LN44@main:

; 701  :       }
; 702  : 
; 703  :     } // end "for num_words" loop

	jmp	$LN14@main
$LN15@main:

; 704  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN50@main

; 705  :       printf("\t#DBG %s@%d # Bottom of while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	eax, BYTE PTR _keepRunning$[ebp]
	test	eax, eax
	je	SHORT $LN56@main
	mov	DWORD PTR tv311[ebp], OFFSET $SG75558
	jmp	SHORT $LN57@main
$LN56@main:
	mov	DWORD PTR tv311[ebp], OFFSET $SG75559
$LN57@main:
	mov	ecx, DWORD PTR tv311[ebp]
	push	ecx
	push	705					; 000002c1H
	push	OFFSET $SG75560
	push	OFFSET $SG75561
	call	_printf
	add	esp, 16					; 00000010H
$LN50@main:

; 706  :     }
; 707  :   } // end "while (keepRunning)" loop

	jmp	$LN9@main
$LN10@main:

; 708  :   printf("\nWaiting for you pressing -Enter- (or do something with WinDBG ;-)\n");

	push	OFFSET $SG75562
	call	_printf
	add	esp, 4
$LN19@main:

; 709  :   int endkey;
; 710  :   do {
; 711  :     endkey = getchar();

	call	_getchar
	mov	DWORD PTR _endkey$[ebp], eax

; 712  :   } while (endkey != '\n');    // Clear keybd buffer and wait for Enter

	cmp	DWORD PTR _endkey$[ebp], 10		; 0000000aH
	jne	SHORT $LN19@main

; 713  : 
; 714  : // Return to OS
; 715  :   return EXIT_SUCCESS;

	xor	eax, eax
$LN1@main:

; 716  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN59@main:
	DD	$LN26@main
	DD	$LN25@main
	DD	$LN24@main
	DD	$LN20@main
	DD	$LN21@main
	DD	$LN31@main
$LN58@main:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv83 = -12						; size = 4
tv81 = -8						; size = 4
_yes$ = -2						; size = 1
_answer$ = -1						; size = 1
_another_round PROC

; 378  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 379  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN4@another_ro

; 380  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	380					; 0000017cH
	push	OFFSET $SG75429
	push	OFFSET $SG75430
	call	_printf
	add	esp, 12					; 0000000cH
$LN4@another_ro:

; 381  :   }
; 382  : 
; 383  :   printf("Another round ? [j/n] ");

	push	OFFSET $SG75431
	call	_printf
	add	esp, 4

; 384  :   char answer = (char)tolower(getchar()) ; // read pressed key from keyboard

	call	_getchar
	push	eax
	call	_tolower
	add	esp, 4
	mov	BYTE PTR _answer$[ebp], al

; 385  :   // drop superfluous characters
; 386  :   if (answer != '\n') {

	movsx	eax, BYTE PTR _answer$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
$LN2@another_ro:

; 387  :     while (getchar() != '\n') ;   // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
	jmp	SHORT $LN2@another_ro
$LN3@another_ro:

; 388  :   }
; 389  :   bool yes = ((answer == 'j') || (answer == '\n')) ;

	movsx	ecx, BYTE PTR _answer$[ebp]
	cmp	ecx, 106				; 0000006aH
	je	SHORT $LN8@another_ro
	movsx	edx, BYTE PTR _answer$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN8@another_ro
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN9@another_ro
$LN8@another_ro:
	mov	DWORD PTR tv81[ebp], 1
$LN9@another_ro:
	cmp	DWORD PTR tv81[ebp], 0
	jne	SHORT $LN10@another_ro
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN11@another_ro
$LN10@another_ro:
	mov	DWORD PTR tv83[ebp], 1
$LN11@another_ro:
	mov	al, BYTE PTR tv83[ebp]
	mov	BYTE PTR _yes$[ebp], al

; 390  :   if (yes) {

	movzx	ecx, BYTE PTR _yes$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@another_ro

; 391  :     printf("\nOK, now go ahead...\n");

	push	OFFSET $SG75434
	call	_printf
	add	esp, 4
$LN6@another_ro:

; 392  :   }
; 393  :   return yes;

	movzx	eax, BYTE PTR _yes$[ebp]

; 394  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_another_round ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv74 = -8						; size = 4
_counter$1 = -4						; size = 4
_state$ = 8						; size = 4
_print_result PROC

; 339  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 340  : 
; 341  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN7@print_resu

; 342  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	342					; 00000156H
	push	OFFSET $SG75408
	push	OFFSET $SG75409
	call	_printf
	add	esp, 12					; 0000000cH
$LN7@print_resu:

; 343  :   }
; 344  :   // Show result in a nice way (ANSI escape sequences for coloring)
; 345  :   // Explanation see http://jafrog.com/2013/11/23/colors-in-terminal.html
; 346  :   // or https://ss64.com/nt/syntax-ansi.html
; 347  :   // Hint: \033 (3*8+3=27) is an octal representation of 0x1B (dec 27 = ESC)
; 348  :   printf("! ");

	push	OFFSET $SG75410
	call	_printf
	add	esp, 4

; 349  : 
; 350  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@print_resu
$LN2@print_resu:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@print_resu:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@print_resu

; 351  :     switch (state->result[counter]) {

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 1
	je	SHORT $LN10@print_resu
	cmp	DWORD PTR tv74[ebp], 2
	je	SHORT $LN9@print_resu
	cmp	DWORD PTR tv74[ebp], 3
	je	SHORT $LN8@print_resu
	jmp	SHORT $LN10@print_resu
$LN8@print_resu:

; 352  :       case CORRECT:
; 353  :         // Characters in the right position marked with green background
; 354  :         printf("\033[37;42;1m");  // ESC writen as octal number (3*8+3 = 27)

	push	OFFSET $SG75412
	call	_printf
	add	esp, 4

; 355  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN9@print_resu:

; 356  :       case PRESENT:
; 357  :         // Characters in word but wrong positioned marked with yellow background
; 358  :         printf("\x1b[37;43;1m");   // ESC writen as hexadecimal number (1*16 + 11 = 27)

	push	OFFSET $SG75414
	call	_printf
	add	esp, 4

; 359  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN10@print_resu:

; 360  :       case NOT_PRESENT:
; 361  :         // Characters not in word not marked at all, but:
; 362  :         // since there is no "break"-Statement, they are processd
; 363  :         // by the following "default:" branch
; 364  :         // In short: "case NOT_PRESENT" and "default:" refers to the same code
; 365  :       default:    // the "else" branch of this switch-statement
; 366  :         // Characters not in word marked with red background
; 367  :         // Characters not in word marked with red background
; 368  :         printf("\033[37;41;1m");

	push	OFFSET $SG75417
	call	_printf
	add	esp, 4
$LN5@print_resu:

; 369  :         break; // break ends this switch-part
; 370  :     }
; 371  :     printf("%c", state->guess[counter]);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _counter$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	push	edx
	push	OFFSET $SG75418
	call	_printf
	add	esp, 8

; 372  :   }

	jmp	SHORT $LN2@print_resu
$LN3@print_resu:

; 373  :   // Reset font and background colors to their defaults
; 374  :   printf("\033[0m\n");

	push	OFFSET $SG75419
	call	_printf
	add	esp, 4

; 375  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_print_result ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv157 = -12						; size = 4
_charin$1 = -8						; size = 4
_bad_word$ = -1						; size = 1
_state$ = 8						; size = 4
_get_input PROC

; 262  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 263  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN12@get_input

; 264  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	264					; 00000108H
	push	OFFSET $SG75371
	push	OFFSET $SG75372
	call	_printf
	add	esp, 12					; 0000000cH
$LN12@get_input:

; 265  :   }
; 266  : 
; 267  :   // loop until user input ok
; 268  :   bool bad_word;
; 269  :   do {      // while (bad_word)
; 270  :     printf("\n%d. trial (#=exit) : ", state->n_tries);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET $SG75373
	call	_printf
	add	esp, 8

; 271  :     // read input from console (WORD_LENGTH characters)
; 272  :     bad_word = false;

	mov	BYTE PTR _bad_word$[ebp], 0

; 273  :     for (int charin = 0; charin < WORD_LENGTH; charin++) {

	mov	DWORD PTR _charin$1[ebp], 0
	jmp	SHORT $LN7@get_input
$LN5@get_input:
	mov	edx, DWORD PTR _charin$1[ebp]
	add	edx, 1
	mov	DWORD PTR _charin$1[ebp], edx
$LN7@get_input:
	cmp	DWORD PTR _charin$1[ebp], 5
	jge	SHORT $LN6@get_input

; 274  :       state->guess[charin] = getchar();         // read character from console

	call	_getchar
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [ecx+4], al

; 275  :   
; 276  :       if (state->guess[charin] == '#') {         // Asterisk means exit program

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _charin$1[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN13@get_input
$LN8@get_input:

; 277  :         while (getchar() != '\n') {};           // // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@get_input
	jmp	SHORT $LN8@get_input
$LN9@get_input:

; 278  :         return false;

	xor	al, al
	jmp	$LN1@get_input
$LN13@get_input:

; 279  :       }
; 280  :       if (state->guess[charin] == '/n') {       // Enter means end-of-input

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, 12142				; 00002f6eH
	jne	SHORT $LN14@get_input

; 281  :         state->guess[charin] = '\0';

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [eax+4], 0

; 282  :         bad_word = true;

	mov	BYTE PTR _bad_word$[ebp], 1

; 283  :         break;    // exit for-loop

	jmp	SHORT $LN6@get_input
$LN14@get_input:

; 284  :       } 
; 285  :     }

	jmp	SHORT $LN5@get_input
$LN6@get_input:

; 286  :     // read (and drop) remaining characters (after the WORD_LENGTH one) using a while-loop
; 287  :     if (!bad_word) {

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@get_input
$LN10@get_input:

; 288  :       while (getchar() != '\n') {};         // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN11@get_input
	jmp	SHORT $LN10@get_input
$LN11@get_input:

; 289  :     }
; 290  : 
; 291  :     // set end of string to char after WORD_LENGTH
; 292  :     state->guess[WORD_LENGTH] = '\0';

	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [ecx+eax+4], 0

; 293  : 
; 294  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN16@get_input

; 295  :       printf("\t#DBG %s@%d # Input: [%s]\n", __func__, __LINE__, state->guess);

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 4
	push	edx
	push	295					; 00000127H
	push	OFFSET $SG75378
	push	OFFSET $SG75379
	call	_printf
	add	esp, 16					; 00000010H
$LN16@get_input:

; 296  :     }
; 297  : 
; 298  :     // process incorrect user input
; 299  :     if (bad_word) {

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN17@get_input

; 300  :       printf("Please enter exactly (!) %d characters !\n", WORD_LENGTH);

	push	5
	push	OFFSET $SG75382
	call	_printf
	add	esp, 8

; 301  :     }

	jmp	SHORT $LN21@get_input
$LN17@get_input:

; 302  :     else {
; 303  : /*    
; 304  :   Deactivated the following two statements as we get only character hints if we hit a word from the wordlist
; 305  :   So if one doesn't know the wordlist, guessing is nearly impossible
; 306  : 	    bad_word = !word_is_allowed(state->guess);
; 307  : 	    if (bad_word)
; 308  : */      
; 309  : 
; 310  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN19@get_input

; 311  :         printf("\t#DBG %s@%d # Back from word_is_allowed\n", __func__, __LINE__);

	push	311					; 00000137H
	push	OFFSET $SG75384
	push	OFFSET $SG75385
	call	_printf
	add	esp, 12					; 0000000cH
$LN19@get_input:

; 312  :       }
; 313  :       if (!word_is_allowed(state->guess)) {

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 4
	push	ecx
	call	_word_is_allowed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@get_input

; 314  :         printf("Word not found in my wordlist\n");

	push	OFFSET $SG75388
	call	_printf
	add	esp, 4

; 315  :       }

	jmp	SHORT $LN21@get_input
$LN20@get_input:

; 316  :       else {
; 317  :         printf("Word found in my wordlist\n");

	push	OFFSET $SG75389
	call	_printf
	add	esp, 4
$LN21@get_input:

; 318  :       }
; 319  : 
; 320  :     }
; 321  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN22@get_input

; 322  :       printf("\t#DBG %s@%d # badword is  %s\n", __func__, __LINE__, bad_word ? "true" : "false");

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN25@get_input
	mov	DWORD PTR tv157[ebp], OFFSET $SG75391
	jmp	SHORT $LN26@get_input
$LN25@get_input:
	mov	DWORD PTR tv157[ebp], OFFSET $SG75392
$LN26@get_input:
	mov	ecx, DWORD PTR tv157[ebp]
	push	ecx
	push	322					; 00000142H
	push	OFFSET $SG75393
	push	OFFSET $SG75394
	call	_printf
	add	esp, 16					; 00000010H
$LN22@get_input:

; 323  :     }
; 324  : 
; 325  :   } while (bad_word) ;   // end "do ... while" loop

	movzx	edx, BYTE PTR _bad_word$[ebp]
	test	edx, edx
	jne	$LN12@get_input

; 326  : 
; 327  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN23@get_input

; 328  :     printf("\t#DBG %s@%d # Leaving function\n", __func__, __LINE__);

	push	328					; 00000148H
	push	OFFSET $SG75396
	push	OFFSET $SG75397
	call	_printf
	add	esp, 12					; 0000000cH
$LN23@get_input:

; 329  :   }
; 330  : 
; 331  :   return true;

	mov	al, 1
$LN1@get_input:

; 332  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv142 = -16						; size = 4
_counter$1 = -12					; size = 4
_counter$2 = -8						; size = 4
_counter$3 = -4						; size = 4
_state$ = 8						; size = 4
_update_state PROC

; 221  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 222  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN11@update_sta

; 223  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	223					; 000000dfH
	push	OFFSET $SG75351
	push	OFFSET $SG75352
	call	_printf
	add	esp, 12					; 0000000cH
$LN11@update_sta:

; 224  :   }
; 225  :  
; 226  :   // mark every character as "unmarked" before we process the input
; 227  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@update_sta
$LN2@update_sta:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@update_sta:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@update_sta

; 228  :     state->result[counter] = UNMARKED;

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], 0

; 229  :     state->used[counter] = false;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [eax+32], 0

; 230  :   }

	jmp	SHORT $LN2@update_sta
$LN3@update_sta:

; 231  : 
; 232  :   // find correct characters and mark then
; 233  :   // (Btw: I don't understand, why this and the upper loop aren't combined ?
; 234  :   //      there's no reference to other array elements than "counter" ?!?,
; 235  :   //      maybe later combine them ?)
; 236  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN7@update_sta
$LN5@update_sta:
	mov	ecx, DWORD PTR _counter$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$3[ebp], ecx
$LN7@update_sta:
	cmp	DWORD PTR _counter$3[ebp], 5
	jge	SHORT $LN6@update_sta

; 237  :     if (state->guess[counter] == state->word[counter]) {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _counter$3[ebp]
	movsx	edx, BYTE PTR [edx+ecx]
	cmp	eax, edx
	jne	SHORT $LN12@update_sta

; 238  :       state->result[counter] = CORRECT;

	mov	eax, DWORD PTR _counter$3[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], 3

; 239  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	mov	BYTE PTR [edx+32], 1
$LN12@update_sta:

; 240  :     }
; 241  :   }

	jmp	SHORT $LN5@update_sta
$LN6@update_sta:

; 242  : 
; 243  :   // Now process every character that's there but not on the right position
; 244  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$2[ebp], 0
	jmp	SHORT $LN10@update_sta
$LN8@update_sta:
	mov	eax, DWORD PTR _counter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$2[ebp], eax
$LN10@update_sta:
	cmp	DWORD PTR _counter$2[ebp], 5
	jge	SHORT $LN9@update_sta

; 245  :     // if character is marked CORRECT, skip it
; 246  :     if (state->result[counter] == CORRECT) {

	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+ecx*4+12], 3
	jne	SHORT $LN13@update_sta

; 247  :       continue;    // next for-loop

	jmp	SHORT $LN8@update_sta
$LN13@update_sta:

; 248  :     }
; 249  :                             // call subfunction in this source and set result
; 250  :                             // (PRESENT/NOT_PRESENT) depending on bool return of subfunction
; 251  :     state->result[counter] = is_character_unmarked(state, state->guess[counter])

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$2[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_is_character_unmarked
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@update_sta
	mov	DWORD PTR tv142[ebp], 2
	jmp	SHORT $LN16@update_sta
$LN15@update_sta:
	mov	DWORD PTR tv142[ebp], 1
$LN16@update_sta:
	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 252  :       ? PRESENT
; 253  :       : NOT_PRESENT;
; 254  :   }

	jmp	SHORT $LN8@update_sta
$LN9@update_sta:

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_update_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_counter$1 = -8						; size = 4
_charfound$ = -1					; size = 1
_state$ = 8						; size = 4
_c$ = 12						; size = 1
_is_character_unmarked PROC

; 199  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 200  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN5@is_charact

; 201  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	201					; 000000c9H
	push	OFFSET $SG75332
	push	OFFSET $SG75333
	call	_printf
	add	esp, 12					; 0000000cH
$LN5@is_charact:

; 202  :   }
; 203  : 
; 204  :   bool charfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _charfound$[ebp], 0

; 205  : 
; 206  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@is_charact
$LN2@is_charact:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@is_charact:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@is_charact

; 207  :     if ( (state->word[counter] == c) && (state->used[counter] == false) ) {

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _counter$1[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@is_charact
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LN6@is_charact

; 208  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [edx+32], 1

; 209  :       charfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _charfound$[ebp], 1

; 210  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@is_charact
$LN6@is_charact:

; 211  :     }
; 212  :   }

	jmp	SHORT $LN2@is_charact
$LN3@is_charact:

; 213  :   return charfound;     // exit subfunction with scan results

	movzx	eax, BYTE PTR _charfound$[ebp]

; 214  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_is_character_unmarked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv130 = -12						; size = 4
_counter$1 = -8						; size = 4
_wordfound$ = -1					; size = 1
_word$ = 8						; size = 4
_word_is_allowed PROC

; 163  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 164  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN5@word_is_al

; 165  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	165					; 000000a5H
	push	OFFSET $SG75308
	push	OFFSET $SG75309
	call	_printf
	add	esp, 12					; 0000000cH
$LN5@word_is_al:

; 166  :   }
; 167  : 
; 168  :   // Sequential search the guessed word in wordlist
; 169  :   bool wordfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _wordfound$[ebp], 0

; 170  :   for (int counter = 0; (words[counter] != NULL); ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@word_is_al
$LN2@word_is_al:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@word_is_al:
	mov	ecx, DWORD PTR _counter$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	$LN3@word_is_al

; 171  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN6@word_is_al

; 172  :       printf("\t#DBG %s@%d # strncmp [%s] with [%s]\n", __func__, __LINE__, word, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	push	172					; 000000acH
	push	OFFSET $SG75311
	push	OFFSET $SG75312
	call	_printf
	add	esp, 20					; 00000014H
$LN6@word_is_al:

; 173  :     }
; 174  :     if (strncmp(word, words[counter], WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@word_is_al

; 175  :       wordfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _wordfound$[ebp], 1

; 176  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN8@word_is_al

; 177  :         printf("\t#DBG %s@%d # found word %s\n", __func__, __LINE__, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	push	177					; 000000b1H
	push	OFFSET $SG75315
	push	OFFSET $SG75316
	call	_printf
	add	esp, 16					; 00000010H
$LN8@word_is_al:

; 178  :       }
; 179  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@word_is_al
$LN7@word_is_al:

; 180  :     }
; 181  :   }

	jmp	$LN2@word_is_al
$LN3@word_is_al:

; 182  : 
; 183  :   // Return the search result (true/false) to caller
; 184  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN9@word_is_al

; 185  :     printf("\t#DBG %s@%d # Returning with '%s'\n", __func__, __LINE__, wordfound ? "true" : "false");

	movzx	ecx, BYTE PTR _wordfound$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@word_is_al
	mov	DWORD PTR tv130[ebp], OFFSET $SG75318
	jmp	SHORT $LN12@word_is_al
$LN11@word_is_al:
	mov	DWORD PTR tv130[ebp], OFFSET $SG75319
$LN12@word_is_al:
	mov	edx, DWORD PTR tv130[ebp]
	push	edx
	push	185					; 000000b9H
	push	OFFSET $SG75320
	push	OFFSET $SG75321
	call	_printf
	add	esp, 16					; 00000010H
$LN9@word_is_al:

; 186  :   }
; 187  :   return wordfound;

	movzx	eax, BYTE PTR _wordfound$[ebp]

; 188  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_word_is_allowed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 551  :         {

	push	ebp
	mov	ebp, esp

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 553  :         }

	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 844  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
