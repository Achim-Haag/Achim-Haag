; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34433.0 

	TITLE	C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_word_is_allowed
PUBLIC	_is_character_unmarked
PUBLIC	_update_state
PUBLIC	_get_input
PUBLIC	_get_input_from_github
PUBLIC	_print_result
PUBLIC	_another_round
PUBLIC	_main
EXTRN	_tolower:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__SetConsoleMode@8:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_getchar:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__time64:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_words:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_DATA	SEGMENT
$SG75275 DB	'word_is_allowed', 00H
$SG75276 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75277 DB	'word_is_allowed', 00H
$SG75278 DB	09H, '#DBG %s@%d # strncmp [%s] with [%s]', 0aH, 00H
	ORG $+2
$SG75280 DB	'word_is_allowed', 00H
$SG75281 DB	09H, '#DBG %s@%d # found word %s', 0aH, 00H
	ORG $+3
$SG75282 DB	'true', 00H
	ORG $+3
$SG75283 DB	'false', 00H
	ORG $+2
$SG75284 DB	'word_is_allowed', 00H
$SG75285 DB	09H, '#DBG %s@%d # Returning with ''%s''', 0aH, 00H
	ORG $+1
$SG75295 DB	'is_character_unmarked', 00H
	ORG $+2
$SG75296 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75313 DB	'update_state', 00H
	ORG $+3
$SG75314 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75330 DB	'get_input', 00H
	ORG $+2
$SG75331 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75332 DB	0aH, '%d. trial: ', 00H
	ORG $+3
$SG75335 DB	'get_input', 00H
	ORG $+2
$SG75336 DB	09H, '#DBG %s@%d # Input: [%s]', 0aH, 00H
	ORG $+1
$SG75339 DB	'Please enter exactly (!) %d characters !', 0aH, 00H
	ORG $+2
$SG75340 DB	'get_input', 00H
	ORG $+2
$SG75341 DB	09H, '#DBG %s@%d # Back from word_is_allowed', 0aH, 00H
	ORG $+3
$SG75344 DB	'Word not found in my wordlist', 0aH, 00H
	ORG $+1
$SG75345 DB	'Word found in my wordlist', 0aH, 00H
	ORG $+1
$SG75346 DB	'true', 00H
	ORG $+3
$SG75347 DB	'false', 00H
	ORG $+2
$SG75348 DB	'get_input', 00H
	ORG $+2
$SG75349 DB	09H, '#DBG %s@%d # badword is  %s', 0aH, 00H
	ORG $+2
$SG75350 DB	'get_input', 00H
	ORG $+2
$SG75351 DB	09H, '#DBG %s@%d # Leaving function', 0aH, 00H
$SG75365 DB	0aH, '%d. Versuch: ', 00H
	ORG $+1
$SG75370 DB	'Bitte %d Buchstaben eingeben.', 0aH, 00H
	ORG $+1
$SG75372 DB	'Das Wort ist nicht in der Liste erlaubter W', 0c3H, 0b6H
	DB	'rter.', 0aH, 00H
$SG75373 DB	'Bottom of while-loop, bad_word is %d', 0aH, 00H
	ORG $+2
$SG75374 DB	'Exit while-loop, bad_word is %d', 0aH, 00H
	ORG $+3
$SG75384 DB	'print_result', 00H
	ORG $+3
$SG75385 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75386 DB	'! ', 00H
	ORG $+1
$SG75388 DB	01bH, '[37;42;1m', 00H
	ORG $+1
$SG75390 DB	01bH, '[37;43;1m', 00H
	ORG $+1
$SG75393 DB	01bH, '[37;41;1m', 00H
	ORG $+1
$SG75394 DB	'%c', 00H
	ORG $+1
$SG75395 DB	01bH, '[0m', 0aH, 00H
	ORG $+2
$SG75404 DB	'another_round', 00H
	ORG $+2
$SG75405 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75406 DB	'Another round ? [j/n] ', 00H
	ORG $+1
$SG75409 DB	0aH, 'OK, now go ahead...', 0aH, 00H
	ORG $+2
$SG75437 DB	'13:43:18', 00H
	ORG $+3
$SG75438 DB	'Nov 30 2024', 00H
$SG75439 DB	'***** Running %s,', 0aH, 'Binary build date: %s @ %s ***'
	DB	'**', 0aH, 0aH, 00H
	ORG $+7
$SG75441 DB	'Cannot get handle for standard device (STD_OUTPUT_HANDLE'
	DB	'), GetStdHandle RC=%d', 00H
	ORG $+2
$SG75443 DB	'Cannot get console mode, GetConsoleMode RC=%d', 00H
	ORG $+2
$SG75445 DB	'Cannot set console mode to virt. terminal proc., SetCons'
	DB	'oleMode RC=%d', 00H
	ORG $+2
$SG75446 DB	'Initial random generator seed: %d', 0aH, 00H
	ORG $+5
$SG75447 DB	0aH, 'NERD WORD', 0aH, 0aH, 'Guess the word with %d chara'
	DB	'cters in no more than %d trials.', 0aH, '(Abort = Ctrl+C)', 0aH
	DB	00H
	ORG $+1
$SG75448 DB	'true', 00H
	ORG $+3
$SG75449 DB	'false', 00H
	ORG $+2
$SG75450 DB	'main', 00H
	ORG $+3
$SG75451 DB	09H, '#DBG %s@%d # Entering while-loop, keepRunning is %s'
	DB	0aH, 00H
	ORG $+2
$SG75452 DB	'main', 00H
	ORG $+3
$SG75453 DB	09H, '#DBG %s@%d # Calling game_state', 0aH, 00H
	ORG $+2
$SG75454 DB	'main', 00H
	ORG $+3
$SG75455 DB	09H, '#DBG %s@%d # Table word count is %d', 0aH, 00H
	ORG $+2
$SG75456 DB	'main', 00H
	ORG $+3
$SG75457 DB	09H, '#DBG %s@%d # Hint: %s', 0aH, 00H
$SG75458 DB	'main', 00H
	ORG $+3
$SG75459 DB	09H, '#DBG %s@%d # Entering for-loop, state.n_tries is %d'
	DB	0aH, 00H
	ORG $+2
$SG75460 DB	'main', 00H
	ORG $+3
$SG75461 DB	09H, '#DBG %s@%d # Calling get_input', 0aH, 00H
	ORG $+3
$SG75462 DB	'main', 00H
	ORG $+3
$SG75463 DB	09H, '#DBG %s@%d # Calling update_state', 0aH, 00H
$SG75466 DB	0aH, 'Yee-haw, you''ve won after %d. trials!', 0aH, 00H
$SG75468 DB	'You don''t guess the word, it was %s.', 0aH, 00H
	ORG $+2
$SG75469 DB	'true', 00H
	ORG $+3
$SG75470 DB	'false', 00H
	ORG $+2
$SG75471 DB	'main', 00H
	ORG $+3
$SG75472 DB	09H, '#DBG %s@%d # Bottom of while-loop, keepRunning is %'
	DB	's', 0aH, 00H
	ORG $+1
$SG75473 DB	0aH, 'Waiting for you debugging me,', 0aH, 'please press '
	DB	'Enter after debugging has ended', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	0348H
voltbl	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv198 = -84						; size = 4
tv143 = -80						; size = 4
_seed$ = -76						; size = 4
tv131 = -72						; size = 4
_hOut$ = -68						; size = 4
_dwMode$ = -64						; size = 4
_num_words$1 = -60					; size = 4
_LastError$ = -56					; size = 4
_doRestart$2 = -50					; size = 1
_keepRunning$ = -49					; size = 1
_state$3 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 416  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 417  : 
; 418  : 
; 419  : /*
; 420  :   To be sure, I run the least compiled .exe:
; 421  :   #pragma message: print filename (source) and  compile/build date/time while compiling/building and
; 422  :   printf : print filename (.exe) and  compile/build date/time when running
; 423  : */
; 424  : #pragma message ("***** Build " __FILE__ " at " __DATE__ " " __TIME__ "*****")   
; 425  :   printf("***** Running %s,\nBinary build date: %s @ %s *****\n\n", argv[0], __DATE__, __TIME__);

	push	OFFSET $SG75437
	push	OFFSET $SG75438
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET $SG75439
	call	_printf
	add	esp, 16					; 00000010H

; 426  : 
; 427  : /*
; 428  :   To enable ANSI text formatting in Windows cmd.exe, I had to add some extra code in my environment (W10 22H2)
; 429  :   Stolen from https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-select-anniversary-update-features
; 430  :   Chapter "Samples" - "Example of SGR terminal sequences"
; 431  : */
; 432  : 
; 433  : #if _MSC_VER          // Necessary only in Windows environment as bash should know ANSI by default
; 434  : 
; 435  : /*
; 436  :   Enable Windows 10 cmd.exe ANSI processing
; 437  : */
; 438  :   // Set output mode to handle virtual terminal sequences
; 439  :   DWORD LastError = 0;          // Keep GetLastError in own variable to not interfere with printf

	mov	DWORD PTR _LastError$[ebp], 0

; 440  :   HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	mov	DWORD PTR _hOut$[ebp], eax

; 441  :   if (hOut == INVALID_HANDLE_VALUE)   {

	cmp	DWORD PTR _hOut$[ebp], -1
	jne	SHORT $LN10@main

; 442  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 443  :     printf("Cannot get handle for standard device (STD_OUTPUT_HANDLE), GetStdHandle RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75441
	call	_printf
	add	esp, 8

; 444  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN10@main:

; 445  :   }
; 446  : 
; 447  :   DWORD dwMode = 0;

	mov	DWORD PTR _dwMode$[ebp], 0

; 448  :   if (!GetConsoleMode(hOut, &dwMode)) {

	lea	edx, DWORD PTR _dwMode$[ebp]
	push	edx
	mov	eax, DWORD PTR _hOut$[ebp]
	push	eax
	call	DWORD PTR __imp__GetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN11@main

; 449  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 450  :     printf ("Cannot get console mode, GetConsoleMode RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75443
	call	_printf
	add	esp, 8

; 451  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN11@main:

; 452  :   }
; 453  : 
; 454  :   dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;

	mov	edx, DWORD PTR _dwMode$[ebp]
	or	edx, 4
	mov	DWORD PTR _dwMode$[ebp], edx

; 455  :   if (!SetConsoleMode(hOut, dwMode)) {

	mov	eax, DWORD PTR _dwMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOut$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN12@main

; 456  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 457  :     printf("Cannot set console mode to virt. terminal proc., SetConsoleMode RC=%d", LastError);

	mov	edx, DWORD PTR _LastError$[ebp]
	push	edx
	push	OFFSET $SG75445
	call	_printf
	add	esp, 8

; 458  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN12@main:

; 459  :   }
; 460  : 
; 461  : /*    In sample, but unused here
; 462  : 
; 463  :     // Try some Set Graphics Rendition (SGR) terminal escape sequences
; 464  :     wprintf(L"\x1b[31mThis text has a red foreground using SGR.31.\r\n");
; 465  :     wprintf(L"\x1b[1mThis text has a bright (bold) red foreground using SGR.1 to affect the previous color setting.\r\n");
; 466  :     wprintf(L"\x1b[mThis text has returned to default colors using SGR.0 implicitly.\r\n");
; 467  :     wprintf(L"\x1b[34;46mThis text shows the foreground and background change at the same time.\r\n");
; 468  :     wprintf(L"\x1b[0mThis text has returned to default colors using SGR.0 explicitly.\r\n");
; 469  :     wprintf(L"\x1b[31;32;33;34;35;36;101;102;103;104;105;106;107mThis text attempts to apply many colors in the same command. Note the colors are applied from left to right so only the right-most option of foreground cyan (SGR.36) and background bright white (SGR.107) is effective.\r\n");
; 470  :     wprintf(L"\x1b[39mThis text has restored the foreground color only.\r\n");
; 471  :     wprintf(L"\x1b[49mThis text has restored the background color only.\r\n");
; 472  : 
; 473  :     return 0;
; 474  : */
; 475  : 
; 476  : #endif    // End Windows ANSI enabling section 
; 477  : 
; 478  : 
; 479  : /************************* TEST END *************************** */
; 480  : 
; 481  : /*
; 482  :     The following "ternary operator" replaces an if/then/else clause.
; 483  :     Question mark is "then", colon is "else".
; 484  :     If the number of parameters given to this program (including argument 1 = Path+Filename of this program)
; 485  :     is greater than 1, an argument is given explicitly and determins the "random seed".
; 486  :     This eases testing as for a specific initial random seed the random generator returns the same series of numbers
; 487  :     If no explicit parameter is specified, the actual timestamp is used for the initialization of the random generater,
; 488  :     leading to nonpredictable random number series.
; 489  : */
; 490  :   unsigned int seed = (argc > 1)

	cmp	DWORD PTR _argc$[ebp], 1
	jle	SHORT $LN17@main
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN18@main
$LN17@main:
	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR tv131[ebp], eax
$LN18@main:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR _seed$[ebp], eax

; 491  :                       ? (unsigned int)atoi(argv[1])
; 492  :                       : (unsigned int)time(NULL) ;
; 493  : 
; 494  :   printf("Initial random generator seed: %d\n", seed);

	mov	ecx, DWORD PTR _seed$[ebp]
	push	ecx
	push	OFFSET $SG75446
	call	_printf
	add	esp, 8

; 495  : 
; 496  : /*
; 497  :     Prepare the random number generation for later use of the "rand" function
; 498  : */
; 499  :   srand(seed);

	mov	edx, DWORD PTR _seed$[ebp]
	push	edx
	call	_srand
	add	esp, 4

; 500  : 
; 501  :   printf("\nNERD WORD\n\n"

	push	6
	push	5
	push	OFFSET $SG75447
	call	_printf
	add	esp, 12					; 0000000cH

; 502  :          "Guess the word with %d characters in no more than %d trials.\n"
; 503  :          "(Abort = Ctrl+C)\n",
; 504  :          WORD_LENGTH, MAX_TRIES);
; 505  : 
; 506  : /*
; 507  :     We run this program until the user aborts.
; 508  :     we cannot see at this moment, how this decision is made, but we know, 
; 509  :     it must made by setting keepRunning to it's logical value "false".
; 510  : */
; 511  :   bool keepRunning = true;

	mov	BYTE PTR _keepRunning$[ebp], 1
$LN2@main:

; 512  :   while (keepRunning) {

	movzx	eax, BYTE PTR _keepRunning$[ebp]
	test	eax, eax
	je	$LN3@main

; 513  : 
; 514  : #ifdef MYDEBUG
; 515  :     printf("\t#DBG %s@%d # Entering while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	ecx, BYTE PTR _keepRunning$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@main
	mov	DWORD PTR tv143[ebp], OFFSET $SG75448
	jmp	SHORT $LN20@main
$LN19@main:
	mov	DWORD PTR tv143[ebp], OFFSET $SG75449
$LN20@main:
	mov	edx, DWORD PTR tv143[ebp]
	push	edx
	push	515					; 00000203H
	push	OFFSET $SG75450
	push	OFFSET $SG75451
	call	_printf
	add	esp, 16					; 00000010H

; 516  : #endif
; 517  : 
; 518  : 
; 519  : /*
; 520  :     First of all create a "real instance" of type game_state, it's name is "state"
; 521  :     It's a structure combining multiple elements in storage (here we need our RAM ;-)
; 522  :     The layout of the structure is defined above as a typeset "game_state"
; 523  :     so "game_state" is - from a higher point of view - the same as an integer, character, string, whatever
; 524  :     But...as far as I think, it's no "executable" statement, it just reserves memory in it's scope
; 525  :     (the compiler generates code to allocate RAM)
; 526  :     Btw: scope means here: "main"
; 527  : */
; 528  : #ifdef MYDEBUG
; 529  :     printf("\t#DBG %s@%d # Calling game_state\n", __func__, __LINE__);

	push	529					; 00000211H
	push	OFFSET $SG75452
	push	OFFSET $SG75453
	call	_printf
	add	esp, 12					; 0000000cH

; 530  : #endif
; 531  :     game_state state;
; 532  : 
; 533  : /*
; 534  :     Count all words in the wordlist (until we reach a null pointer element)
; 535  : */
; 536  :     int num_words;
; 537  :     for (num_words = 0; words[num_words] != NULL; num_words++) {};  // One-line loop

	mov	DWORD PTR _num_words$1[ebp], 0
	jmp	SHORT $LN6@main
$LN4@main:
	mov	eax, DWORD PTR _num_words$1[ebp]
	add	eax, 1
	mov	DWORD PTR _num_words$1[ebp], eax
$LN6@main:
	mov	ecx, DWORD PTR _num_words$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	SHORT $LN5@main
	jmp	SHORT $LN4@main
$LN5@main:

; 538  : 
; 539  : #ifdef MYDEBUG
; 540  :     printf("\t#DBG %s@%d # Table word count is %d\n", __func__, __LINE__, num_words);

	mov	edx, DWORD PTR _num_words$1[ebp]
	push	edx
	push	540					; 0000021cH
	push	OFFSET $SG75454
	push	OFFSET $SG75455
	call	_printf
	add	esp, 16					; 00000010H

; 541  : #endif
; 542  : 
; 543  : /*
; 544  :     Now we fill one variable - the pointer to the word - with the address of a randomly selected
; 545  :     word of our wordlist (that comes out of words.c which is linked together with this program)
; 546  :     Important: as the word in array "words" is addressed by modulo (%) NUM_WORDS,
; 547  :     NUM_WORDS must not be higher than the real number of words in the array "words",
; 548  :     else something unpredictable would occur
; 549  :     (maybe NUM_WORDS should be defined near "words" if this is possible ?)
; 550  :     Debugging: the other variables in structure "state" are undefined at the first entry into the loop
; 551  : */
; 552  :     state.word = words[rand() % num_words];

	call	_rand
	cdq
	idiv	DWORD PTR _num_words$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	mov	DWORD PTR _state$3[ebp], eax

; 553  : 
; 554  : /*
; 555  :     only for testing: show me the selected word
; 556  :     #-marked statements are processed by the compilers preprocessor
; 557  :     (personally, I call it precompiler in memoriam to PL/I ;-)
; 558  :     To activate this printf, a compiler option "-D DEBUG" must be given that defines DEBUG (no value needed)
; 559  :     Not to be confused with _DEBUG (underscore !) that is defined by MSVC by the /MTd or /MDd option,
; 560  :     see https://learn.microsoft.com/en-us/cpp/c-runtime-library/debug?view=msvc-170
; 561  :     Changed to my own precompiler variable MYDEBUG for simplicity
; 562  : */
; 563  : #ifdef MYDEBUG
; 564  :     printf("\t#DBG %s@%d # Hint: %s\n", __func__, __LINE__, state.word);

	mov	ecx, DWORD PTR _state$3[ebp]
	push	ecx
	push	564					; 00000234H
	push	OFFSET $SG75456
	push	OFFSET $SG75457
	call	_printf
	add	esp, 16					; 00000010H

; 565  : #endif
; 566  : 
; 567  : /*
; 568  :   Now we run another loop that asks our guesses of the characters
; 569  :   The for loop counts a number variable from a starting point to an ending point
; 570  :   In the C language, the ending point doesn't has to be dependend on the number variable alone,
; 571  :   it can be extended by other logical expressions
; 572  : */
; 573  :     bool doRestart = false;

	mov	BYTE PTR _doRestart$2[ebp], 0

; 574  :     for (state.n_tries = 1; 

	mov	DWORD PTR _state$3[ebp+40], 1
	jmp	SHORT $LN9@main
$LN7@main:

; 576  :          ++state.n_tries)    {

	mov	edx, DWORD PTR _state$3[ebp+40]
	add	edx, 1
	mov	DWORD PTR _state$3[ebp+40], edx
$LN9@main:

; 575  :          state.n_tries <= MAX_TRIES && !doRestart;

	cmp	DWORD PTR _state$3[ebp+40], 6
	jg	$LN8@main
	movzx	eax, BYTE PTR _doRestart$2[ebp]
	test	eax, eax
	jne	$LN8@main

; 577  : #ifdef MYDEBUG
; 578  :       printf("\t#DBG %s@%d # Entering for-loop, state.n_tries is %d\n", __func__, __LINE__, state.n_tries);

	mov	ecx, DWORD PTR _state$3[ebp+40]
	push	ecx
	push	578					; 00000242H
	push	OFFSET $SG75458
	push	OFFSET $SG75459
	call	_printf
	add	esp, 16					; 00000010H

; 579  : #endif
; 580  :     
; 581  : /*
; 582  :     we call the above defined function to get user's input.
; 583  :     The "&" means: give the address of variable (structure) "state" to this function,
; 584  :     so this function is able to modify this structure - i.e. the structure's variables
; 585  : */   
; 586  : 
; 587  :     // ask user for keyboard input
; 588  : #ifdef MYDEBUG
; 589  :       printf("\t#DBG %s@%d # Calling get_input\n", __func__, __LINE__);

	push	589					; 0000024dH
	push	OFFSET $SG75460
	push	OFFSET $SG75461
	call	_printf
	add	esp, 12					; 0000000cH

; 590  : #endif
; 591  :       get_input(&state);

	lea	edx, DWORD PTR _state$3[ebp]
	push	edx
	call	_get_input
	add	esp, 4

; 592  : 
; 593  :     // process user's input
; 594  : #ifdef MYDEBUG
; 595  :       printf("\t#DBG %s@%d # Calling update_state\n", __func__, __LINE__);

	push	595					; 00000253H
	push	OFFSET $SG75462
	push	OFFSET $SG75463
	call	_printf
	add	esp, 12					; 0000000cH

; 596  : #endif
; 597  :       update_state(&state);

	lea	eax, DWORD PTR _state$3[ebp]
	push	eax
	call	_update_state
	add	esp, 4

; 598  : 
; 599  :     // show results
; 600  :       print_result(&state);

	lea	ecx, DWORD PTR _state$3[ebp]
	push	ecx
	call	_print_result
	add	esp, 4

; 601  : 
; 602  :     // Compare input word with word to guess, if equal, user wins
; 603  :       if (strncmp(state.guess, state.word, WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _state$3[ebp]
	push	edx
	lea	eax, DWORD PTR _state$3[ebp+4]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@main

; 604  :         printf ("\nYee-haw, you've won after %d. trials!\n", state.n_tries);

	mov	ecx, DWORD PTR _state$3[ebp+40]
	push	ecx
	push	OFFSET $SG75466
	call	_printf
	add	esp, 8

; 605  :         doRestart = true;

	mov	BYTE PTR _doRestart$2[ebp], 1

; 606  :         keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al

; 607  :       }

	jmp	SHORT $LN15@main
$LN13@main:

; 608  :       else {
; 609  :         if (state.n_tries == MAX_TRIES) {

	cmp	DWORD PTR _state$3[ebp+40], 6
	jne	SHORT $LN15@main

; 610  :           printf("You don't guess the word, it was %s.\n", state.word);

	mov	edx, DWORD PTR _state$3[ebp]
	push	edx
	push	OFFSET $SG75468
	call	_printf
	add	esp, 8

; 611  :           keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al
$LN15@main:

; 612  :         }
; 613  :       }
; 614  : 
; 615  :     } // end "for num_words" loop

	jmp	$LN7@main
$LN8@main:

; 616  : #ifdef MYDEBUG
; 617  :       printf("\t#DBG %s@%d # Bottom of while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	eax, BYTE PTR _keepRunning$[ebp]
	test	eax, eax
	je	SHORT $LN21@main
	mov	DWORD PTR tv198[ebp], OFFSET $SG75469
	jmp	SHORT $LN22@main
$LN21@main:
	mov	DWORD PTR tv198[ebp], OFFSET $SG75470
$LN22@main:
	mov	ecx, DWORD PTR tv198[ebp]
	push	ecx
	push	617					; 00000269H
	push	OFFSET $SG75471
	push	OFFSET $SG75472
	call	_printf
	add	esp, 16					; 00000010H

; 618  : #endif
; 619  :   } // end "while (keepRunning)" loop

	jmp	$LN2@main
$LN3@main:

; 620  :   printf("\nWaiting for you debugging me,\nplease press Enter after debugging has ended\n");

	push	OFFSET $SG75473
	call	_printf
	add	esp, 4

; 621  :   return EXIT_SUCCESS;

	xor	eax, eax
$LN1@main:

; 622  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv80 = -8						; size = 4
_yes$ = -2						; size = 1
_answer$ = -1						; size = 1
_another_round PROC

; 394  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 395  : #ifdef MYDEBUG
; 396  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	396					; 0000018cH
	push	OFFSET $SG75404
	push	OFFSET $SG75405
	call	_printf
	add	esp, 12					; 0000000cH

; 397  : #endif
; 398  : 
; 399  :   printf("Another round ? [j/n] ");

	push	OFFSET $SG75406
	call	_printf
	add	esp, 4

; 400  :   char answer = (char)tolower(getchar()) ; // read pressed key from keyboard

	call	_getchar
	push	eax
	call	_tolower
	add	esp, 4
	mov	BYTE PTR _answer$[ebp], al

; 401  :   // drop superfluous characters
; 402  :   if (answer != '\n') {

	movsx	eax, BYTE PTR _answer$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
$LN2@another_ro:

; 403  :     while (getchar() != '\n') ;

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
	jmp	SHORT $LN2@another_ro
$LN3@another_ro:

; 404  :   }
; 405  :   bool yes = ((answer == 'j') || (answer == '\n')) ;

	movsx	ecx, BYTE PTR _answer$[ebp]
	cmp	ecx, 106				; 0000006aH
	je	SHORT $LN7@another_ro
	movsx	edx, BYTE PTR _answer$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN7@another_ro
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN8@another_ro
$LN7@another_ro:
	mov	DWORD PTR tv80[ebp], 1
$LN8@another_ro:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN9@another_ro
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN10@another_ro
$LN9@another_ro:
	mov	DWORD PTR tv82[ebp], 1
$LN10@another_ro:
	mov	al, BYTE PTR tv82[ebp]
	mov	BYTE PTR _yes$[ebp], al

; 406  :   if (yes) {

	movzx	ecx, BYTE PTR _yes$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@another_ro

; 407  :     printf("\nOK, now go ahead...\n");

	push	OFFSET $SG75409
	call	_printf
	add	esp, 4
$LN5@another_ro:

; 408  :   }
; 409  :   return yes;

	movzx	eax, BYTE PTR _yes$[ebp]

; 410  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_another_round ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv73 = -8						; size = 4
_counter$1 = -4						; size = 4
_state$ = 8						; size = 4
_print_result PROC

; 355  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 356  : 
; 357  : #ifdef MYDEBUG
; 358  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	358					; 00000166H
	push	OFFSET $SG75384
	push	OFFSET $SG75385
	call	_printf
	add	esp, 12					; 0000000cH

; 359  : #endif
; 360  :   // Show result in a nice way (ANSI escape sequences for coloring)
; 361  :   // Explanation see http://jafrog.com/2013/11/23/colors-in-terminal.html
; 362  :   // or https://ss64.com/nt/syntax-ansi.html
; 363  :   // Hint: \033 (3*8+3=27) is an octal representation of 0x1B (dec 27 = ESC)
; 364  :   printf("! ");

	push	OFFSET $SG75386
	call	_printf
	add	esp, 4

; 365  : 
; 366  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@print_resu
$LN2@print_resu:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@print_resu:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@print_resu

; 367  :     switch (state->result[counter]) {

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 1
	je	SHORT $LN9@print_resu
	cmp	DWORD PTR tv73[ebp], 2
	je	SHORT $LN8@print_resu
	cmp	DWORD PTR tv73[ebp], 3
	je	SHORT $LN7@print_resu
	jmp	SHORT $LN9@print_resu
$LN7@print_resu:

; 368  :       case CORRECT:
; 369  :         // Characters in the right position marked with green background
; 370  :         printf("\033[37;42;1m");  // ESC writen as octal number (3*8+3 = 27)

	push	OFFSET $SG75388
	call	_printf
	add	esp, 4

; 371  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN8@print_resu:

; 372  :       case PRESENT:
; 373  :         // Characters in word but wrong positioned marked with yellow background
; 374  :         printf("\x1b[37;43;1m");   // ESC writen as hexadecimal number (1*16 + 11 = 27)

	push	OFFSET $SG75390
	call	_printf
	add	esp, 4

; 375  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN9@print_resu:

; 376  :       case NOT_PRESENT:
; 377  :         // Characters not in word not marked at all, but:
; 378  :         // since there is no "break"-Statement, they are processd
; 379  :         // by the following "default:" branch
; 380  :         // In short: "case NOT_PRESENT" and "default:" refers to the same code
; 381  :       default:    // the "else" branch of this switch-statement
; 382  :         // Characters not in word marked with red background
; 383  :         // Characters not in word marked with red background
; 384  :         printf("\033[37;41;1m");

	push	OFFSET $SG75393
	call	_printf
	add	esp, 4
$LN5@print_resu:

; 385  :         break; // break ends this switch-part
; 386  :     }
; 387  :     printf("%c", state->guess[counter]);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _counter$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	push	edx
	push	OFFSET $SG75394
	call	_printf
	add	esp, 8

; 388  :   }

	jmp	SHORT $LN2@print_resu
$LN3@print_resu:

; 389  :   // Reset font and background colors to their defaults
; 390  :   printf("\033[0m\n");

	push	OFFSET $SG75395
	call	_printf
	add	esp, 4

; 391  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_print_result ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_bad_word$ = -1						; size = 1
_state$ = 8						; size = 4
_get_input_from_github PROC

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
$LN4@get_input_:

; 304  :     // solange eine Eingabe anfordern, bis sie gültig ist
; 305  :     bool bad_word;
; 306  :     do
; 307  :     {
; 308  :         printf("\n%d. Versuch: ", state->n_tries);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET $SG75365
	call	_printf
	add	esp, 8

; 309  :         // Eingabe lesen
; 310  :         bad_word = false;

	mov	BYTE PTR _bad_word$[ebp], 0

; 311  :         for (int i = 0; i < WORD_LENGTH; i++) {

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN7@get_input_
$LN5@get_input_:
	mov	edx, DWORD PTR _i$1[ebp]
	add	edx, 1
	mov	DWORD PTR _i$1[ebp], edx
$LN7@get_input_:
	cmp	DWORD PTR _i$1[ebp], 5
	jge	SHORT $LN6@get_input_

; 312  :             state->guess[i] = getchar();

	call	_getchar
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx+4], al

; 313  :             if (state->guess[i] == '\n') {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _i$1[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN10@get_input_

; 314  :                 state->guess[i] = '\0';

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _i$1[ebp]
	mov	BYTE PTR [ecx+4], 0

; 315  :                 bad_word = true;

	mov	BYTE PTR _bad_word$[ebp], 1

; 316  :                 break;

	jmp	SHORT $LN6@get_input_
$LN10@get_input_:

; 317  :             }
; 318  :         }

	jmp	SHORT $LN5@get_input_
$LN6@get_input_:

; 319  :         // überflüssige Zeichen verwerfen
; 320  :         if (!bad_word)

	movzx	edx, BYTE PTR _bad_word$[ebp]
	test	edx, edx
	jne	SHORT $LN9@get_input_
$LN8@get_input_:

; 321  :             while (getchar() != '\n')

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@get_input_

; 322  :                 ;

	jmp	SHORT $LN8@get_input_
$LN9@get_input_:

; 323  :         // nach dem 5. Zeichen abschneiden
; 324  :         state->guess[WORD_LENGTH] = '\0';

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [edx+ecx+4], 0

; 325  : #ifdef DEBUG
; 326  :         printf("Eingabe: '%s'\n", state->guess);
; 327  : #endif
; 328  :         if (bad_word) {

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN12@get_input_

; 329  :             printf("Bitte %d Buchstaben eingeben.\n", WORD_LENGTH);

	push	5
	push	OFFSET $SG75370
	call	_printf
	add	esp, 8

; 330  : 	} else {

	jmp	SHORT $LN14@get_input_
$LN12@get_input_:

; 331  : 
; 332  : /*    
; 333  : 	    bad_word = !word_is_allowed(state->guess);
; 334  : 	    if (bad_word)
; 335  : */      
; 336  :       if (!word_is_allowed(state->guess))

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 4
	push	ecx
	call	_word_is_allowed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@get_input_

; 337  : 		    printf("Das Wort ist nicht in der Liste erlaubter Wörter.\n");

	push	OFFSET $SG75372
	call	_printf
	add	esp, 4
$LN14@get_input_:

; 338  : 	}
; 339  : 
; 340  : printf("Bottom of while-loop, bad_word is %d\n", bad_word);

	movzx	eax, BYTE PTR _bad_word$[ebp]
	push	eax
	push	OFFSET $SG75373
	call	_printf
	add	esp, 8

; 341  : 
; 342  :     }
; 343  :     while (bad_word);

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	jne	$LN4@get_input_

; 344  : printf("Exit while-loop, bad_word is %d\n", bad_word);

	movzx	edx, BYTE PTR _bad_word$[ebp]
	push	edx
	push	OFFSET $SG75374
	call	_printf
	add	esp, 8

; 345  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_input_from_github ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv146 = -12						; size = 4
_charin$1 = -8						; size = 4
_bad_word$ = -1						; size = 1
_state$ = 8						; size = 4
_get_input PROC

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 232  : 
; 233  : #ifdef MYDEBUG
; 234  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	234					; 000000eaH
	push	OFFSET $SG75330
	push	OFFSET $SG75331
	call	_printf
	add	esp, 12					; 0000000cH
$LN4@get_input:

; 235  : #endif
; 236  : 
; 237  :   // loop until user input ok
; 238  :   bool bad_word;
; 239  :   do {      // while (bad_word)
; 240  :     printf("\n%d. trial: ", state->n_tries);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET $SG75332
	call	_printf
	add	esp, 8

; 241  :     // read input from console (WORD_LENGTH characters)
; 242  :     bad_word = false;

	mov	BYTE PTR _bad_word$[ebp], 0

; 243  :     for (int charin = 0; charin < WORD_LENGTH; charin++) {

	mov	DWORD PTR _charin$1[ebp], 0
	jmp	SHORT $LN7@get_input
$LN5@get_input:
	mov	edx, DWORD PTR _charin$1[ebp]
	add	edx, 1
	mov	DWORD PTR _charin$1[ebp], edx
$LN7@get_input:
	cmp	DWORD PTR _charin$1[ebp], 5
	jge	SHORT $LN6@get_input

; 244  :       state->guess[charin] = getchar();         // read character from console

	call	_getchar
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [ecx+4], al

; 245  :       if (state->guess[charin] == '/n') {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _charin$1[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 12142				; 00002f6eH
	jne	SHORT $LN10@get_input

; 246  :         state->guess[charin] = '\0';

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [ecx+4], 0

; 247  :         bad_word = true;

	mov	BYTE PTR _bad_word$[ebp], 1

; 248  :         break;    // exit for-loop

	jmp	SHORT $LN6@get_input
$LN10@get_input:

; 249  :       } 
; 250  :     }

	jmp	SHORT $LN5@get_input
$LN6@get_input:

; 251  :     // read (and drop) remaining characters (after the WORD_LENGTH one) using a while-loop
; 252  :     if (!bad_word) {

	movzx	edx, BYTE PTR _bad_word$[ebp]
	test	edx, edx
	jne	SHORT $LN9@get_input
$LN8@get_input:

; 253  :       while (getchar() != '\n') {};

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@get_input
	jmp	SHORT $LN8@get_input
$LN9@get_input:

; 254  :     }
; 255  : 
; 256  :     // set end of string to char after WORD_LENGTH
; 257  :     state->guess[WORD_LENGTH] = '\0';

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [edx+ecx+4], 0

; 258  : 
; 259  : #ifdef MYDEBUG
; 260  :     printf("\t#DBG %s@%d # Input: [%s]\n", __func__, __LINE__, state->guess);

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, 4
	push	eax
	push	260					; 00000104H
	push	OFFSET $SG75335
	push	OFFSET $SG75336
	call	_printf
	add	esp, 16					; 00000010H

; 261  : #endif
; 262  : 
; 263  :     // process incorrect user input
; 264  :     if (bad_word) {

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@get_input

; 265  :       printf("Please enter exactly (!) %d characters !\n", WORD_LENGTH);

	push	5
	push	OFFSET $SG75339
	call	_printf
	add	esp, 8

; 266  :     }

	jmp	SHORT $LN15@get_input
$LN12@get_input:

; 267  :     else {
; 268  : /*    
; 269  :   Uncommented the following two statements as one gets only character hints guessing a word from the wordlist
; 270  :   So if one doesn't know the wordlist, guessing is nearly impossible
; 271  : 	    bad_word = !word_is_allowed(state->guess);
; 272  : 	    if (bad_word)
; 273  : */      
; 274  : 
; 275  : #ifdef MYDEBUG
; 276  :       printf("\t#DBG %s@%d # Back from word_is_allowed\n", __func__, __LINE__);

	push	276					; 00000114H
	push	OFFSET $SG75340
	push	OFFSET $SG75341
	call	_printf
	add	esp, 12					; 0000000cH

; 277  : #endif
; 278  :       if (!word_is_allowed(state->guess)) {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 4
	push	edx
	call	_word_is_allowed
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN14@get_input

; 279  :         printf("Word not found in my wordlist\n");

	push	OFFSET $SG75344
	call	_printf
	add	esp, 4

; 280  :       }

	jmp	SHORT $LN15@get_input
$LN14@get_input:

; 281  :       else {
; 282  :         printf("Word found in my wordlist\n");

	push	OFFSET $SG75345
	call	_printf
	add	esp, 4
$LN15@get_input:

; 283  :       }
; 284  : 
; 285  :     }
; 286  : #ifdef MYDEBUG
; 287  :     printf("\t#DBG %s@%d # badword is  %s\n", __func__, __LINE__, bad_word ? "true" : "false");

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	je	SHORT $LN17@get_input
	mov	DWORD PTR tv146[ebp], OFFSET $SG75346
	jmp	SHORT $LN18@get_input
$LN17@get_input:
	mov	DWORD PTR tv146[ebp], OFFSET $SG75347
$LN18@get_input:
	mov	edx, DWORD PTR tv146[ebp]
	push	edx
	push	287					; 0000011fH
	push	OFFSET $SG75348
	push	OFFSET $SG75349
	call	_printf
	add	esp, 16					; 00000010H

; 288  : #endif
; 289  :   } while (bad_word) ;   // end "do ... while" loop

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	jne	$LN4@get_input

; 290  : 
; 291  : #ifdef MYDEBUG
; 292  :   printf("\t#DBG %s@%d # Leaving function\n", __func__, __LINE__);

	push	292					; 00000124H
	push	OFFSET $SG75350
	push	OFFSET $SG75351
	call	_printf
	add	esp, 12					; 0000000cH

; 293  : #endif
; 294  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv141 = -16						; size = 4
_counter$1 = -12					; size = 4
_counter$2 = -8						; size = 4
_counter$3 = -4						; size = 4
_state$ = 8						; size = 4
_update_state PROC

; 190  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 191  : #ifdef MYDEBUG
; 192  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	192					; 000000c0H
	push	OFFSET $SG75313
	push	OFFSET $SG75314
	call	_printf
	add	esp, 12					; 0000000cH

; 193  : #endif
; 194  :  
; 195  :   // mark every character as "unmarked" before we process the input
; 196  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@update_sta
$LN2@update_sta:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@update_sta:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@update_sta

; 197  :     state->result[counter] = UNMARKED;

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], 0

; 198  :     state->used[counter] = false;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [eax+32], 0

; 199  :   }

	jmp	SHORT $LN2@update_sta
$LN3@update_sta:

; 200  : 
; 201  :   // find correct characters and mark then
; 202  :   // (Btw: I don't understand, why this and the upper loop aren't combined ?
; 203  :   //      there's no reference to other array elements than "counter" ?!?,
; 204  :   //      maybe later combine them ?)
; 205  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN7@update_sta
$LN5@update_sta:
	mov	ecx, DWORD PTR _counter$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$3[ebp], ecx
$LN7@update_sta:
	cmp	DWORD PTR _counter$3[ebp], 5
	jge	SHORT $LN6@update_sta

; 206  :     if (state->guess[counter] == state->word[counter]) {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _counter$3[ebp]
	movsx	edx, BYTE PTR [edx+ecx]
	cmp	eax, edx
	jne	SHORT $LN11@update_sta

; 207  :       state->result[counter] = CORRECT;

	mov	eax, DWORD PTR _counter$3[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], 3

; 208  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	mov	BYTE PTR [edx+32], 1
$LN11@update_sta:

; 209  :     }
; 210  :   }

	jmp	SHORT $LN5@update_sta
$LN6@update_sta:

; 211  : 
; 212  :   // Now process every character that's there but not on the right position
; 213  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$2[ebp], 0
	jmp	SHORT $LN10@update_sta
$LN8@update_sta:
	mov	eax, DWORD PTR _counter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$2[ebp], eax
$LN10@update_sta:
	cmp	DWORD PTR _counter$2[ebp], 5
	jge	SHORT $LN9@update_sta

; 214  :     // if character is marked CORRECT, skip it
; 215  :     if (state->result[counter] == CORRECT) {

	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+ecx*4+12], 3
	jne	SHORT $LN12@update_sta

; 216  :       continue;    // next for-loop

	jmp	SHORT $LN8@update_sta
$LN12@update_sta:

; 217  :     }
; 218  :                             // call subfunction in this source and set result
; 219  :                             // (PRESENT/NOT_PRESENT) depending on bool return of subfunction
; 220  :     state->result[counter] = is_character_unmarked(state, state->guess[counter])

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$2[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_is_character_unmarked
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@update_sta
	mov	DWORD PTR tv141[ebp], 2
	jmp	SHORT $LN15@update_sta
$LN14@update_sta:
	mov	DWORD PTR tv141[ebp], 1
$LN15@update_sta:
	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 221  :       ? PRESENT
; 222  :       : NOT_PRESENT;
; 223  :   }

	jmp	SHORT $LN8@update_sta
$LN9@update_sta:

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_update_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_counter$1 = -8						; size = 4
_charfound$ = -1					; size = 1
_state$ = 8						; size = 4
_c$ = 12						; size = 1
_is_character_unmarked PROC

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 169  : #ifdef MYDEBUG
; 170  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	170					; 000000aaH
	push	OFFSET $SG75295
	push	OFFSET $SG75296
	call	_printf
	add	esp, 12					; 0000000cH

; 171  : #endif
; 172  : 
; 173  :   bool charfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _charfound$[ebp], 0

; 174  : 
; 175  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@is_charact
$LN2@is_charact:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@is_charact:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@is_charact

; 176  :     if ( (state->word[counter] == c) && (state->used[counter] == false) ) {

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _counter$1[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN5@is_charact
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LN5@is_charact

; 177  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [edx+32], 1

; 178  :       charfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _charfound$[ebp], 1

; 179  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@is_charact
$LN5@is_charact:

; 180  :     }
; 181  :   }

	jmp	SHORT $LN2@is_charact
$LN3@is_charact:

; 182  :   return charfound;     // exit subfunction with scan results

	movzx	eax, BYTE PTR _charfound$[ebp]

; 183  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_is_character_unmarked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv94 = -12						; size = 4
_counter$1 = -8						; size = 4
_wordfound$ = -1					; size = 1
_word$ = 8						; size = 4
_word_is_allowed PROC

; 132  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 133  : #ifdef MYDEBUG
; 134  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	134					; 00000086H
	push	OFFSET $SG75275
	push	OFFSET $SG75276
	call	_printf
	add	esp, 12					; 0000000cH

; 135  : #endif
; 136  : 
; 137  :   // Sequential search the guessed word in wordlist
; 138  :   bool wordfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _wordfound$[ebp], 0

; 139  :   for (int counter = 0; (words[counter] != NULL); ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@word_is_al
$LN2@word_is_al:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@word_is_al:
	mov	ecx, DWORD PTR _counter$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	SHORT $LN3@word_is_al

; 140  : #ifdef MYDEBUG
; 141  :     printf("\t#DBG %s@%d # strncmp [%s] with [%s]\n", __func__, __LINE__, word, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	push	141					; 0000008dH
	push	OFFSET $SG75277
	push	OFFSET $SG75278
	call	_printf
	add	esp, 20					; 00000014H

; 142  : #endif
; 143  :     if (strncmp(word, words[counter], WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@word_is_al

; 144  :       wordfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _wordfound$[ebp], 1

; 145  : #ifdef MYDEBUG
; 146  :       printf("\t#DBG %s@%d # found word %s\n", __func__, __LINE__, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	push	146					; 00000092H
	push	OFFSET $SG75280
	push	OFFSET $SG75281
	call	_printf
	add	esp, 16					; 00000010H

; 147  : #endif
; 148  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@word_is_al
$LN5@word_is_al:

; 149  :     }
; 150  :   }

	jmp	$LN2@word_is_al
$LN3@word_is_al:

; 151  : 
; 152  :   // Return the search result (true/false) to caller
; 153  : #ifdef MYDEBUG
; 154  :   printf("\t#DBG %s@%d # Returning with '%s'\n", __func__, __LINE__, wordfound ? "true" : "false");

	movzx	ecx, BYTE PTR _wordfound$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@word_is_al
	mov	DWORD PTR tv94[ebp], OFFSET $SG75282
	jmp	SHORT $LN8@word_is_al
$LN7@word_is_al:
	mov	DWORD PTR tv94[ebp], OFFSET $SG75283
$LN8@word_is_al:
	mov	edx, DWORD PTR tv94[ebp]
	push	edx
	push	154					; 0000009aH
	push	OFFSET $SG75284
	push	OFFSET $SG75285
	call	_printf
	add	esp, 16					; 00000010H

; 155  : #endif
; 156  :   return wordfound;

	movzx	eax, BYTE PTR _wordfound$[ebp]

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_word_is_allowed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 551  :         {

	push	ebp
	mov	ebp, esp

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 553  :         }

	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
