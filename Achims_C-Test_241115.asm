; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34433.0 

	TITLE	C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_word_is_allowed
PUBLIC	_is_character_unmarked
PUBLIC	_update_state
PUBLIC	_get_input
PUBLIC	_print_result
PUBLIC	_another_round
PUBLIC	_main
EXTRN	_tolower:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__SetConsoleMode@8:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_getchar:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__time64:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_words:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_DATA	SEGMENT
$SG75275 DB	'word_is_allowed', 00H
$SG75276 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75277 DB	'word_is_allowed', 00H
$SG75278 DB	09H, '#DBG %s@%d # strncmp [%s] with [%s]', 0aH, 00H
	ORG $+2
$SG75280 DB	'word_is_allowed', 00H
$SG75281 DB	09H, '#DBG %s@%d # found word %s', 0aH, 00H
	ORG $+3
$SG75282 DB	'true', 00H
	ORG $+3
$SG75283 DB	'false', 00H
	ORG $+2
$SG75284 DB	'word_is_allowed', 00H
$SG75285 DB	09H, '#DBG %s@%d # Returning with ''%s''', 0aH, 00H
	ORG $+1
$SG75295 DB	'is_character_unmarked', 00H
	ORG $+2
$SG75296 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75313 DB	'update_state', 00H
	ORG $+3
$SG75314 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75332 DB	'get_input', 00H
	ORG $+2
$SG75333 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75334 DB	0aH, '%d. trial (#=exit) : ', 00H
	ORG $+1
$SG75338 DB	'get_input', 00H
	ORG $+2
$SG75339 DB	09H, '#DBG %s@%d # Input: [%s]', 0aH, 00H
	ORG $+1
$SG75342 DB	'Please enter exactly (!) %d characters !', 0aH, 00H
	ORG $+2
$SG75343 DB	'get_input', 00H
	ORG $+2
$SG75344 DB	09H, '#DBG %s@%d # Back from word_is_allowed', 0aH, 00H
	ORG $+3
$SG75347 DB	'Word not found in my wordlist', 0aH, 00H
	ORG $+1
$SG75348 DB	'Word found in my wordlist', 0aH, 00H
	ORG $+1
$SG75349 DB	'true', 00H
	ORG $+3
$SG75350 DB	'false', 00H
	ORG $+2
$SG75351 DB	'get_input', 00H
	ORG $+2
$SG75352 DB	09H, '#DBG %s@%d # badword is  %s', 0aH, 00H
	ORG $+2
$SG75353 DB	'get_input', 00H
	ORG $+2
$SG75354 DB	09H, '#DBG %s@%d # Leaving function', 0aH, 00H
$SG75364 DB	'print_result', 00H
	ORG $+3
$SG75365 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75366 DB	'! ', 00H
	ORG $+1
$SG75368 DB	01bH, '[37;42;1m', 00H
	ORG $+1
$SG75370 DB	01bH, '[37;43;1m', 00H
	ORG $+1
$SG75373 DB	01bH, '[37;41;1m', 00H
	ORG $+1
$SG75374 DB	'%c', 00H
	ORG $+1
$SG75375 DB	01bH, '[0m', 0aH, 00H
	ORG $+2
$SG75384 DB	'another_round', 00H
	ORG $+2
$SG75385 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75386 DB	'Another round ? [j/n] ', 00H
	ORG $+1
$SG75389 DB	0aH, 'OK, now go ahead...', 0aH, 00H
	ORG $+2
$SG75421 DB	'14:59:49', 00H
	ORG $+3
$SG75422 DB	'Nov 30 2024', 00H
$SG75423 DB	'***** Running %s,', 0aH, 'Binary build date: %s @ %s ***'
	DB	'**', 0aH, 0aH, 00H
	ORG $+7
$SG75425 DB	'Cannot get handle for standard device (STD_OUTPUT_HANDLE'
	DB	'), GetStdHandle RC=%d', 00H
	ORG $+2
$SG75427 DB	'Cannot get console mode, GetConsoleMode RC=%d', 00H
	ORG $+2
$SG75429 DB	'Cannot set console mode to virt. terminal proc., SetCons'
	DB	'oleMode RC=%d', 00H
	ORG $+2
$SG75430 DB	'Initial random generator seed: %d', 0aH, 00H
	ORG $+5
$SG75431 DB	0aH, 'NERD WORD', 0aH, 0aH, 'Guess the word with %d chara'
	DB	'cters in no more than %d trials.', 0aH, '(Abort = Ctrl+C)', 0aH
	DB	00H
	ORG $+1
$SG75432 DB	'true', 00H
	ORG $+3
$SG75433 DB	'false', 00H
	ORG $+2
$SG75434 DB	'main', 00H
	ORG $+3
$SG75435 DB	09H, '#DBG %s@%d # Entering while-loop, keepRunning is %s'
	DB	0aH, 00H
	ORG $+2
$SG75436 DB	'main', 00H
	ORG $+3
$SG75437 DB	09H, '#DBG %s@%d # Calling game_state', 0aH, 00H
	ORG $+2
$SG75438 DB	'main', 00H
	ORG $+3
$SG75439 DB	09H, '#DBG %s@%d # Table word count is %d', 0aH, 00H
	ORG $+2
$SG75440 DB	'main', 00H
	ORG $+3
$SG75441 DB	09H, '#DBG %s@%d # Hint: %s', 0aH, 00H
$SG75442 DB	'main', 00H
	ORG $+3
$SG75443 DB	09H, '#DBG %s@%d # Entering for-loop, state.n_tries is %d'
	DB	0aH, 00H
	ORG $+2
$SG75444 DB	'main', 00H
	ORG $+3
$SG75445 DB	09H, '#DBG %s@%d # Calling get_input', 0aH, 00H
	ORG $+3
$SG75448 DB	'main', 00H
	ORG $+3
$SG75449 DB	09H, '#DBG %s@%d # Calling update_state', 0aH, 00H
$SG75452 DB	0aH, 'Yee-haw, you''ve won after %d. trials!', 0aH, 00H
$SG75454 DB	'You don''t guess the word, it was %s.', 0aH, 00H
	ORG $+2
$SG75455 DB	'main', 00H
	ORG $+3
$SG75456 DB	09H, '#DBG %s@%d # keepRunning after get_input', 0aH, 00H
	ORG $+1
$SG75457 DB	'true', 00H
	ORG $+3
$SG75458 DB	'false', 00H
	ORG $+2
$SG75459 DB	'main', 00H
	ORG $+3
$SG75460 DB	09H, '#DBG %s@%d # Bottom of while-loop, keepRunning is %'
	DB	's', 0aH, 00H
	ORG $+5
$SG75461 DB	0aH, 'Waiting for you debugging me,', 0aH, 'please press '
	DB	'Enter after debugging has ended', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	0380H
voltbl	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_endkey$ = -88						; size = 4
tv204 = -84						; size = 4
tv143 = -80						; size = 4
_seed$ = -76						; size = 4
tv131 = -72						; size = 4
_hOut$ = -68						; size = 4
_dwMode$ = -64						; size = 4
_num_words$1 = -60					; size = 4
_LastError$ = -56					; size = 4
_doRestart$2 = -50					; size = 1
_keepRunning$ = -49					; size = 1
_state$3 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 369  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 370  : 
; 371  : 
; 372  : /*
; 373  :   To be sure, I run the least compiled .exe:
; 374  :   #pragma message: print filename (source) and  compile/build date/time while compiling/building and
; 375  :   printf : print filename (.exe) and  compile/build date/time when running
; 376  : */
; 377  : #pragma message ("***** Build " __FILE__ " at " __DATE__ " " __TIME__ "*****")   
; 378  :   printf("***** Running %s,\nBinary build date: %s @ %s *****\n\n", argv[0], __DATE__, __TIME__);

	push	OFFSET $SG75421
	push	OFFSET $SG75422
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET $SG75423
	call	_printf
	add	esp, 16					; 00000010H

; 379  : 
; 380  : /*
; 381  :   To enable ANSI text formatting in Windows cmd.exe, I had to add some extra code in my environment (W10 22H2)
; 382  :   Stolen from https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-select-anniversary-update-features
; 383  :   Chapter "Samples" - "Example of SGR terminal sequences"
; 384  : */
; 385  : 
; 386  : #if _MSC_VER          // Necessary only in Windows environment as bash should know ANSI by default
; 387  : 
; 388  : /*
; 389  :   Enable Windows 10 cmd.exe ANSI processing
; 390  : */
; 391  :   // Set output mode to handle virtual terminal sequences
; 392  :   DWORD LastError = 0;          // Keep GetLastError in own variable to not interfere with printf

	mov	DWORD PTR _LastError$[ebp], 0

; 393  :   HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	mov	DWORD PTR _hOut$[ebp], eax

; 394  :   if (hOut == INVALID_HANDLE_VALUE)   {

	cmp	DWORD PTR _hOut$[ebp], -1
	jne	SHORT $LN13@main

; 395  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 396  :     printf("Cannot get handle for standard device (STD_OUTPUT_HANDLE), GetStdHandle RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75425
	call	_printf
	add	esp, 8

; 397  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN13@main:

; 398  :   }
; 399  : 
; 400  :   DWORD dwMode = 0;

	mov	DWORD PTR _dwMode$[ebp], 0

; 401  :   if (!GetConsoleMode(hOut, &dwMode)) {

	lea	edx, DWORD PTR _dwMode$[ebp]
	push	edx
	mov	eax, DWORD PTR _hOut$[ebp]
	push	eax
	call	DWORD PTR __imp__GetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN14@main

; 402  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 403  :     printf ("Cannot get console mode, GetConsoleMode RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75427
	call	_printf
	add	esp, 8

; 404  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN14@main:

; 405  :   }
; 406  : 
; 407  :   dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;

	mov	edx, DWORD PTR _dwMode$[ebp]
	or	edx, 4
	mov	DWORD PTR _dwMode$[ebp], edx

; 408  :   if (!SetConsoleMode(hOut, dwMode)) {

	mov	eax, DWORD PTR _dwMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOut$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN15@main

; 409  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 410  :     printf("Cannot set console mode to virt. terminal proc., SetConsoleMode RC=%d", LastError);

	mov	edx, DWORD PTR _LastError$[ebp]
	push	edx
	push	OFFSET $SG75429
	call	_printf
	add	esp, 8

; 411  :     return LastError;

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN15@main:

; 412  :   }
; 413  : 
; 414  : /*    In sample, but unused here
; 415  : 
; 416  :     // Try some Set Graphics Rendition (SGR) terminal escape sequences
; 417  :     wprintf(L"\x1b[31mThis text has a red foreground using SGR.31.\r\n");
; 418  :     wprintf(L"\x1b[1mThis text has a bright (bold) red foreground using SGR.1 to affect the previous color setting.\r\n");
; 419  :     wprintf(L"\x1b[mThis text has returned to default colors using SGR.0 implicitly.\r\n");
; 420  :     wprintf(L"\x1b[34;46mThis text shows the foreground and background change at the same time.\r\n");
; 421  :     wprintf(L"\x1b[0mThis text has returned to default colors using SGR.0 explicitly.\r\n");
; 422  :     wprintf(L"\x1b[31;32;33;34;35;36;101;102;103;104;105;106;107mThis text attempts to apply many colors in the same command. Note the colors are applied from left to right so only the right-most option of foreground cyan (SGR.36) and background bright white (SGR.107) is effective.\r\n");
; 423  :     wprintf(L"\x1b[39mThis text has restored the foreground color only.\r\n");
; 424  :     wprintf(L"\x1b[49mThis text has restored the background color only.\r\n");
; 425  : 
; 426  :     return 0;
; 427  : */
; 428  : 
; 429  : #endif    // End Windows ANSI enabling section 
; 430  : 
; 431  : 
; 432  : /************************* TEST END *************************** */
; 433  : 
; 434  : /*
; 435  :     The following "ternary operator" replaces an if/then/else clause.
; 436  :     Question mark is "then", colon is "else".
; 437  :     If the number of parameters given to this program (including argument 1 = Path+Filename of this program)
; 438  :     is greater than 1, an argument is given explicitly and determins the "random seed".
; 439  :     This eases testing as for a specific initial random seed the random generator returns the same series of numbers
; 440  :     If no explicit parameter is specified, the actual timestamp is used for the initialization of the random generater,
; 441  :     leading to nonpredictable random number series.
; 442  : */
; 443  :   unsigned int seed = (argc > 1)

	cmp	DWORD PTR _argc$[ebp], 1
	jle	SHORT $LN22@main
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN23@main
$LN22@main:
	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR tv131[ebp], eax
$LN23@main:
	mov	eax, DWORD PTR tv131[ebp]
	mov	DWORD PTR _seed$[ebp], eax

; 444  :                       ? (unsigned int)atoi(argv[1])
; 445  :                       : (unsigned int)time(NULL) ;
; 446  : 
; 447  :   printf("Initial random generator seed: %d\n", seed);

	mov	ecx, DWORD PTR _seed$[ebp]
	push	ecx
	push	OFFSET $SG75430
	call	_printf
	add	esp, 8

; 448  : 
; 449  : /*
; 450  :     Prepare the random number generation for later use of the "rand" function
; 451  : */
; 452  :   srand(seed);

	mov	edx, DWORD PTR _seed$[ebp]
	push	edx
	call	_srand
	add	esp, 4

; 453  : 
; 454  :   printf("\nNERD WORD\n\n"

	push	6
	push	5
	push	OFFSET $SG75431
	call	_printf
	add	esp, 12					; 0000000cH

; 455  :          "Guess the word with %d characters in no more than %d trials.\n"
; 456  :          "(Abort = Ctrl+C)\n",
; 457  :          WORD_LENGTH, MAX_TRIES);
; 458  : 
; 459  : /*
; 460  :     We run this program until the user aborts.
; 461  :     we cannot see at this moment, how this decision is made, but we know, 
; 462  :     it must made by setting keepRunning to it's logical value "false".
; 463  : */
; 464  :   bool keepRunning = true;

	mov	BYTE PTR _keepRunning$[ebp], 1
$LN2@main:

; 465  :   while (keepRunning) {

	movzx	eax, BYTE PTR _keepRunning$[ebp]
	test	eax, eax
	je	$LN3@main

; 466  : 
; 467  : #ifdef MYDEBUG
; 468  :     printf("\t#DBG %s@%d # Entering while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	ecx, BYTE PTR _keepRunning$[ebp]
	test	ecx, ecx
	je	SHORT $LN24@main
	mov	DWORD PTR tv143[ebp], OFFSET $SG75432
	jmp	SHORT $LN25@main
$LN24@main:
	mov	DWORD PTR tv143[ebp], OFFSET $SG75433
$LN25@main:
	mov	edx, DWORD PTR tv143[ebp]
	push	edx
	push	468					; 000001d4H
	push	OFFSET $SG75434
	push	OFFSET $SG75435
	call	_printf
	add	esp, 16					; 00000010H

; 469  : #endif
; 470  : 
; 471  : 
; 472  : /*
; 473  :     First of all create a "real instance" of type game_state, it's name is "state"
; 474  :     It's a structure combining multiple elements in storage (here we need our RAM ;-)
; 475  :     The layout of the structure is defined above as a typeset "game_state"
; 476  :     so "game_state" is - from a higher point of view - the same as an integer, character, string, whatever
; 477  :     But...as far as I think, it's no "executable" statement, it just reserves memory in it's scope
; 478  :     (the compiler generates code to allocate RAM)
; 479  :     Btw: scope means here: "main"
; 480  : */
; 481  : #ifdef MYDEBUG
; 482  :     printf("\t#DBG %s@%d # Calling game_state\n", __func__, __LINE__);

	push	482					; 000001e2H
	push	OFFSET $SG75436
	push	OFFSET $SG75437
	call	_printf
	add	esp, 12					; 0000000cH

; 483  : #endif
; 484  :     game_state state;
; 485  : 
; 486  : /*
; 487  :     Count all words in the wordlist (until we reach a null pointer element)
; 488  : */
; 489  :     int num_words;
; 490  :     for (num_words = 0; words[num_words] != NULL; num_words++) {};  // One-line loop

	mov	DWORD PTR _num_words$1[ebp], 0
	jmp	SHORT $LN6@main
$LN4@main:
	mov	eax, DWORD PTR _num_words$1[ebp]
	add	eax, 1
	mov	DWORD PTR _num_words$1[ebp], eax
$LN6@main:
	mov	ecx, DWORD PTR _num_words$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	SHORT $LN5@main
	jmp	SHORT $LN4@main
$LN5@main:

; 491  : 
; 492  : #ifdef MYDEBUG
; 493  :     printf("\t#DBG %s@%d # Table word count is %d\n", __func__, __LINE__, num_words);

	mov	edx, DWORD PTR _num_words$1[ebp]
	push	edx
	push	493					; 000001edH
	push	OFFSET $SG75438
	push	OFFSET $SG75439
	call	_printf
	add	esp, 16					; 00000010H

; 494  : #endif
; 495  : 
; 496  : /*
; 497  :     Now we fill one variable - the pointer to the word - with the address of a randomly selected
; 498  :     word of our wordlist (that comes out of words.c which is linked together with this program)
; 499  :     Important: as the word in array "words" is addressed by modulo (%) NUM_WORDS,
; 500  :     NUM_WORDS must not be higher than the real number of words in the array "words",
; 501  :     else something unpredictable would occur
; 502  :     (maybe NUM_WORDS should be defined near "words" if this is possible ?)
; 503  :     Debugging: the other variables in structure "state" are undefined at the first entry into the loop
; 504  : */
; 505  :     state.word = words[rand() % num_words];

	call	_rand
	cdq
	idiv	DWORD PTR _num_words$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	mov	DWORD PTR _state$3[ebp], eax

; 506  : 
; 507  : /*
; 508  :     only for testing: show me the selected word
; 509  :     #-marked statements are processed by the compilers preprocessor
; 510  :     (personally, I call it precompiler in memoriam to PL/I ;-)
; 511  :     To activate this printf, a compiler option "-D DEBUG" must be given that defines DEBUG (no value needed)
; 512  :     Not to be confused with _DEBUG (underscore !) that is defined by MSVC by the /MTd or /MDd option,
; 513  :     see https://learn.microsoft.com/en-us/cpp/c-runtime-library/debug?view=msvc-170
; 514  :     Changed to my own precompiler variable MYDEBUG for simplicity
; 515  : */
; 516  : #ifdef MYDEBUG
; 517  :     printf("\t#DBG %s@%d # Hint: %s\n", __func__, __LINE__, state.word);

	mov	ecx, DWORD PTR _state$3[ebp]
	push	ecx
	push	517					; 00000205H
	push	OFFSET $SG75440
	push	OFFSET $SG75441
	call	_printf
	add	esp, 16					; 00000010H

; 518  : #endif
; 519  : 
; 520  : /*
; 521  :   Now we run another loop that asks our guesses of the characters
; 522  :   The for loop counts a number variable from a starting point to an ending point
; 523  :   In the C language, the ending point doesn't has to be dependend on the number variable alone,
; 524  :   it can be extended by other logical expressions
; 525  : */
; 526  :     bool doRestart = false;

	mov	BYTE PTR _doRestart$2[ebp], 0

; 527  :     for (state.n_tries = 1; 

	mov	DWORD PTR _state$3[ebp+40], 1
	jmp	SHORT $LN9@main
$LN7@main:

; 529  :          ++state.n_tries)    {

	mov	edx, DWORD PTR _state$3[ebp+40]
	add	edx, 1
	mov	DWORD PTR _state$3[ebp+40], edx
$LN9@main:

; 528  :          state.n_tries <= MAX_TRIES && !doRestart;

	cmp	DWORD PTR _state$3[ebp+40], 6
	jg	$LN8@main
	movzx	eax, BYTE PTR _doRestart$2[ebp]
	test	eax, eax
	jne	$LN8@main

; 530  : #ifdef MYDEBUG
; 531  :       printf("\t#DBG %s@%d # Entering for-loop, state.n_tries is %d\n", __func__, __LINE__, state.n_tries);

	mov	ecx, DWORD PTR _state$3[ebp+40]
	push	ecx
	push	531					; 00000213H
	push	OFFSET $SG75442
	push	OFFSET $SG75443
	call	_printf
	add	esp, 16					; 00000010H

; 532  : #endif
; 533  :     
; 534  : /*
; 535  :     we call the above defined function to get user's input.
; 536  :     The "&" means: give the address of variable (structure) "state" to this function,
; 537  :     so this function is able to modify this structure - i.e. the structure's variables
; 538  : */   
; 539  : 
; 540  :     // ask user for keyboard input, exit loop if user wants to
; 541  : #ifdef MYDEBUG
; 542  :       printf("\t#DBG %s@%d # Calling get_input\n", __func__, __LINE__);

	push	542					; 0000021eH
	push	OFFSET $SG75444
	push	OFFSET $SG75445
	call	_printf
	add	esp, 12					; 0000000cH

; 543  : #endif
; 544  :       if (get_input(&state)) {

	lea	edx, DWORD PTR _state$3[ebp]
	push	edx
	call	_get_input
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	je	$LN16@main

; 545  : 
; 546  :     // process user's input
; 547  : #ifdef MYDEBUG
; 548  :         printf("\t#DBG %s@%d # Calling update_state\n", __func__, __LINE__);

	push	548					; 00000224H
	push	OFFSET $SG75448
	push	OFFSET $SG75449
	call	_printf
	add	esp, 12					; 0000000cH

; 549  : #endif
; 550  :         update_state(&state);

	lea	ecx, DWORD PTR _state$3[ebp]
	push	ecx
	call	_update_state
	add	esp, 4

; 551  : 
; 552  :       // show results
; 553  :         print_result(&state);

	lea	edx, DWORD PTR _state$3[ebp]
	push	edx
	call	_print_result
	add	esp, 4

; 554  : 
; 555  :       // Compare input word with word to guess, if equal, user wins
; 556  :         if (strncmp(state.guess, state.word, WORD_LENGTH) == 0) {

	push	5
	mov	eax, DWORD PTR _state$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _state$3[ebp+4]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@main

; 557  :           printf ("\nYee-haw, you've won after %d. trials!\n", state.n_tries);

	mov	edx, DWORD PTR _state$3[ebp+40]
	push	edx
	push	OFFSET $SG75452
	call	_printf
	add	esp, 8

; 558  :           doRestart = true;

	mov	BYTE PTR _doRestart$2[ebp], 1

; 559  :           keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al

; 560  :         }

	jmp	SHORT $LN20@main
$LN18@main:

; 561  :         else {
; 562  :           if (state.n_tries == MAX_TRIES) {

	cmp	DWORD PTR _state$3[ebp+40], 6
	jne	SHORT $LN20@main

; 563  :             printf("You don't guess the word, it was %s.\n", state.word);

	mov	eax, DWORD PTR _state$3[ebp]
	push	eax
	push	OFFSET $SG75454
	call	_printf
	add	esp, 8

; 564  :             keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al
$LN20@main:

; 565  :           }
; 566  :         }
; 567  :         
; 568  :       }

	jmp	SHORT $LN17@main
$LN16@main:

; 569  :       else {
; 570  :         keepRunning = false;

	mov	BYTE PTR _keepRunning$[ebp], 0

; 571  :         break; // for-loop

	jmp	SHORT $LN8@main

; 572  : #ifdef MYDEBUG
; 573  :         printf("\t#DBG %s@%d # keepRunning after get_input\n", __func__, __LINE__), keepRunning;

	push	573					; 0000023dH
	push	OFFSET $SG75455
	push	OFFSET $SG75456
	call	_printf
	add	esp, 12					; 0000000cH
$LN17@main:

; 574  : #endif
; 575  : 
; 576  :       }
; 577  : 
; 578  :     } // end "for num_words" loop

	jmp	$LN7@main
$LN8@main:

; 579  : #ifdef MYDEBUG
; 580  :       printf("\t#DBG %s@%d # Bottom of while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	ecx, BYTE PTR _keepRunning$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@main
	mov	DWORD PTR tv204[ebp], OFFSET $SG75457
	jmp	SHORT $LN27@main
$LN26@main:
	mov	DWORD PTR tv204[ebp], OFFSET $SG75458
$LN27@main:
	mov	edx, DWORD PTR tv204[ebp]
	push	edx
	push	580					; 00000244H
	push	OFFSET $SG75459
	push	OFFSET $SG75460
	call	_printf
	add	esp, 16					; 00000010H

; 581  : #endif
; 582  :   } // end "while (keepRunning)" loop

	jmp	$LN2@main
$LN3@main:

; 583  :   printf("\nWaiting for you debugging me,\nplease press Enter after debugging has ended\n");

	push	OFFSET $SG75461
	call	_printf
	add	esp, 4
$LN12@main:

; 584  :   int endkey;
; 585  :   do {
; 586  :     endkey = getchar();

	call	_getchar
	mov	DWORD PTR _endkey$[ebp], eax

; 587  :   } while (endkey != '\n');    // Wait for Enter

	cmp	DWORD PTR _endkey$[ebp], 10		; 0000000aH
	jne	SHORT $LN12@main

; 588  :   return EXIT_SUCCESS;

	xor	eax, eax
$LN1@main:

; 589  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv82 = -12						; size = 4
tv80 = -8						; size = 4
_yes$ = -2						; size = 1
_answer$ = -1						; size = 1
_another_round PROC

; 347  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 348  : #ifdef MYDEBUG
; 349  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	349					; 0000015dH
	push	OFFSET $SG75384
	push	OFFSET $SG75385
	call	_printf
	add	esp, 12					; 0000000cH

; 350  : #endif
; 351  : 
; 352  :   printf("Another round ? [j/n] ");

	push	OFFSET $SG75386
	call	_printf
	add	esp, 4

; 353  :   char answer = (char)tolower(getchar()) ; // read pressed key from keyboard

	call	_getchar
	push	eax
	call	_tolower
	add	esp, 4
	mov	BYTE PTR _answer$[ebp], al

; 354  :   // drop superfluous characters
; 355  :   if (answer != '\n') {

	movsx	eax, BYTE PTR _answer$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
$LN2@another_ro:

; 356  :     while (getchar() != '\n') ;

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
	jmp	SHORT $LN2@another_ro
$LN3@another_ro:

; 357  :   }
; 358  :   bool yes = ((answer == 'j') || (answer == '\n')) ;

	movsx	ecx, BYTE PTR _answer$[ebp]
	cmp	ecx, 106				; 0000006aH
	je	SHORT $LN7@another_ro
	movsx	edx, BYTE PTR _answer$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN7@another_ro
	mov	DWORD PTR tv80[ebp], 0
	jmp	SHORT $LN8@another_ro
$LN7@another_ro:
	mov	DWORD PTR tv80[ebp], 1
$LN8@another_ro:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN9@another_ro
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN10@another_ro
$LN9@another_ro:
	mov	DWORD PTR tv82[ebp], 1
$LN10@another_ro:
	mov	al, BYTE PTR tv82[ebp]
	mov	BYTE PTR _yes$[ebp], al

; 359  :   if (yes) {

	movzx	ecx, BYTE PTR _yes$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@another_ro

; 360  :     printf("\nOK, now go ahead...\n");

	push	OFFSET $SG75389
	call	_printf
	add	esp, 4
$LN5@another_ro:

; 361  :   }
; 362  :   return yes;

	movzx	eax, BYTE PTR _yes$[ebp]

; 363  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_another_round ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv73 = -8						; size = 4
_counter$1 = -4						; size = 4
_state$ = 8						; size = 4
_print_result PROC

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 309  : 
; 310  : #ifdef MYDEBUG
; 311  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	311					; 00000137H
	push	OFFSET $SG75364
	push	OFFSET $SG75365
	call	_printf
	add	esp, 12					; 0000000cH

; 312  : #endif
; 313  :   // Show result in a nice way (ANSI escape sequences for coloring)
; 314  :   // Explanation see http://jafrog.com/2013/11/23/colors-in-terminal.html
; 315  :   // or https://ss64.com/nt/syntax-ansi.html
; 316  :   // Hint: \033 (3*8+3=27) is an octal representation of 0x1B (dec 27 = ESC)
; 317  :   printf("! ");

	push	OFFSET $SG75366
	call	_printf
	add	esp, 4

; 318  : 
; 319  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@print_resu
$LN2@print_resu:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@print_resu:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@print_resu

; 320  :     switch (state->result[counter]) {

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 1
	je	SHORT $LN9@print_resu
	cmp	DWORD PTR tv73[ebp], 2
	je	SHORT $LN8@print_resu
	cmp	DWORD PTR tv73[ebp], 3
	je	SHORT $LN7@print_resu
	jmp	SHORT $LN9@print_resu
$LN7@print_resu:

; 321  :       case CORRECT:
; 322  :         // Characters in the right position marked with green background
; 323  :         printf("\033[37;42;1m");  // ESC writen as octal number (3*8+3 = 27)

	push	OFFSET $SG75368
	call	_printf
	add	esp, 4

; 324  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN8@print_resu:

; 325  :       case PRESENT:
; 326  :         // Characters in word but wrong positioned marked with yellow background
; 327  :         printf("\x1b[37;43;1m");   // ESC writen as hexadecimal number (1*16 + 11 = 27)

	push	OFFSET $SG75370
	call	_printf
	add	esp, 4

; 328  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN9@print_resu:

; 329  :       case NOT_PRESENT:
; 330  :         // Characters not in word not marked at all, but:
; 331  :         // since there is no "break"-Statement, they are processd
; 332  :         // by the following "default:" branch
; 333  :         // In short: "case NOT_PRESENT" and "default:" refers to the same code
; 334  :       default:    // the "else" branch of this switch-statement
; 335  :         // Characters not in word marked with red background
; 336  :         // Characters not in word marked with red background
; 337  :         printf("\033[37;41;1m");

	push	OFFSET $SG75373
	call	_printf
	add	esp, 4
$LN5@print_resu:

; 338  :         break; // break ends this switch-part
; 339  :     }
; 340  :     printf("%c", state->guess[counter]);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _counter$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	push	edx
	push	OFFSET $SG75374
	call	_printf
	add	esp, 8

; 341  :   }

	jmp	SHORT $LN2@print_resu
$LN3@print_resu:

; 342  :   // Reset font and background colors to their defaults
; 343  :   printf("\033[0m\n");

	push	OFFSET $SG75375
	call	_printf
	add	esp, 4

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_print_result ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv153 = -12						; size = 4
_charin$1 = -8						; size = 4
_bad_word$ = -1						; size = 1
_state$ = 8						; size = 4
_get_input PROC

; 232  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 233  : 
; 234  : #ifdef MYDEBUG
; 235  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	235					; 000000ebH
	push	OFFSET $SG75332
	push	OFFSET $SG75333
	call	_printf
	add	esp, 12					; 0000000cH
$LN4@get_input:

; 236  : #endif
; 237  : 
; 238  :   // loop until user input ok
; 239  :   bool bad_word;
; 240  :   do {      // while (bad_word)
; 241  :     printf("\n%d. trial (#=exit) : ", state->n_tries);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET $SG75334
	call	_printf
	add	esp, 8

; 242  :     // read input from console (WORD_LENGTH characters)
; 243  :     bad_word = false;

	mov	BYTE PTR _bad_word$[ebp], 0

; 244  :     for (int charin = 0; charin < WORD_LENGTH; charin++) {

	mov	DWORD PTR _charin$1[ebp], 0
	jmp	SHORT $LN7@get_input
$LN5@get_input:
	mov	edx, DWORD PTR _charin$1[ebp]
	add	edx, 1
	mov	DWORD PTR _charin$1[ebp], edx
$LN7@get_input:
	cmp	DWORD PTR _charin$1[ebp], 5
	jge	SHORT $LN6@get_input

; 245  :       state->guess[charin] = getchar();         // read character from console

	call	_getchar
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [ecx+4], al

; 246  :   
; 247  :       if (state->guess[charin] == '#') {         // Asterisk means exit program

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _charin$1[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN12@get_input
$LN8@get_input:

; 248  :         while (getchar() != '\n') {};           // Clear keyboard buffer

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@get_input
	jmp	SHORT $LN8@get_input
$LN9@get_input:

; 249  :         return false;

	xor	al, al
	jmp	$LN1@get_input
$LN12@get_input:

; 250  :       }
; 251  :       if (state->guess[charin] == '/n') {       // Enter means end-of-input

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, 12142				; 00002f6eH
	jne	SHORT $LN13@get_input

; 252  :         state->guess[charin] = '\0';

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [eax+4], 0

; 253  :         bad_word = true;

	mov	BYTE PTR _bad_word$[ebp], 1

; 254  :         break;    // exit for-loop

	jmp	SHORT $LN6@get_input
$LN13@get_input:

; 255  :       } 
; 256  :     }

	jmp	SHORT $LN5@get_input
$LN6@get_input:

; 257  :     // read (and drop) remaining characters (after the WORD_LENGTH one) using a while-loop
; 258  :     if (!bad_word) {

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@get_input
$LN10@get_input:

; 259  :       while (getchar() != '\n') {};

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN11@get_input
	jmp	SHORT $LN10@get_input
$LN11@get_input:

; 260  :     }
; 261  : 
; 262  :     // set end of string to char after WORD_LENGTH
; 263  :     state->guess[WORD_LENGTH] = '\0';

	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [ecx+eax+4], 0

; 264  : 
; 265  : #ifdef MYDEBUG
; 266  :     printf("\t#DBG %s@%d # Input: [%s]\n", __func__, __LINE__, state->guess);

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 4
	push	edx
	push	266					; 0000010aH
	push	OFFSET $SG75338
	push	OFFSET $SG75339
	call	_printf
	add	esp, 16					; 00000010H

; 267  : #endif
; 268  : 
; 269  :     // process incorrect user input
; 270  :     if (bad_word) {

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN15@get_input

; 271  :       printf("Please enter exactly (!) %d characters !\n", WORD_LENGTH);

	push	5
	push	OFFSET $SG75342
	call	_printf
	add	esp, 8

; 272  :     }

	jmp	SHORT $LN18@get_input
$LN15@get_input:

; 273  :     else {
; 274  : /*    
; 275  :   Uncommented the following two statements as one gets only character hints guessing a word from the wordlist
; 276  :   So if one doesn't know the wordlist, guessing is nearly impossible
; 277  : 	    bad_word = !word_is_allowed(state->guess);
; 278  : 	    if (bad_word)
; 279  : */      
; 280  : 
; 281  : #ifdef MYDEBUG
; 282  :       printf("\t#DBG %s@%d # Back from word_is_allowed\n", __func__, __LINE__);

	push	282					; 0000011aH
	push	OFFSET $SG75343
	push	OFFSET $SG75344
	call	_printf
	add	esp, 12					; 0000000cH

; 283  : #endif
; 284  :       if (!word_is_allowed(state->guess)) {

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 4
	push	ecx
	call	_word_is_allowed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN17@get_input

; 285  :         printf("Word not found in my wordlist\n");

	push	OFFSET $SG75347
	call	_printf
	add	esp, 4

; 286  :       }

	jmp	SHORT $LN18@get_input
$LN17@get_input:

; 287  :       else {
; 288  :         printf("Word found in my wordlist\n");

	push	OFFSET $SG75348
	call	_printf
	add	esp, 4
$LN18@get_input:

; 289  :       }
; 290  : 
; 291  :     }
; 292  : #ifdef MYDEBUG
; 293  :     printf("\t#DBG %s@%d # badword is  %s\n", __func__, __LINE__, bad_word ? "true" : "false");

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN20@get_input
	mov	DWORD PTR tv153[ebp], OFFSET $SG75349
	jmp	SHORT $LN21@get_input
$LN20@get_input:
	mov	DWORD PTR tv153[ebp], OFFSET $SG75350
$LN21@get_input:
	mov	ecx, DWORD PTR tv153[ebp]
	push	ecx
	push	293					; 00000125H
	push	OFFSET $SG75351
	push	OFFSET $SG75352
	call	_printf
	add	esp, 16					; 00000010H

; 294  : #endif
; 295  :   } while (bad_word) ;   // end "do ... while" loop

	movzx	edx, BYTE PTR _bad_word$[ebp]
	test	edx, edx
	jne	$LN4@get_input

; 296  : 
; 297  : #ifdef MYDEBUG
; 298  :   printf("\t#DBG %s@%d # Leaving function\n", __func__, __LINE__);

	push	298					; 0000012aH
	push	OFFSET $SG75353
	push	OFFSET $SG75354
	call	_printf
	add	esp, 12					; 0000000cH

; 299  : #endif
; 300  :   return true;

	mov	al, 1
$LN1@get_input:

; 301  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv141 = -16						; size = 4
_counter$1 = -12					; size = 4
_counter$2 = -8						; size = 4
_counter$3 = -4						; size = 4
_state$ = 8						; size = 4
_update_state PROC

; 191  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 192  : #ifdef MYDEBUG
; 193  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	193					; 000000c1H
	push	OFFSET $SG75313
	push	OFFSET $SG75314
	call	_printf
	add	esp, 12					; 0000000cH

; 194  : #endif
; 195  :  
; 196  :   // mark every character as "unmarked" before we process the input
; 197  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@update_sta
$LN2@update_sta:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@update_sta:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@update_sta

; 198  :     state->result[counter] = UNMARKED;

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], 0

; 199  :     state->used[counter] = false;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [eax+32], 0

; 200  :   }

	jmp	SHORT $LN2@update_sta
$LN3@update_sta:

; 201  : 
; 202  :   // find correct characters and mark then
; 203  :   // (Btw: I don't understand, why this and the upper loop aren't combined ?
; 204  :   //      there's no reference to other array elements than "counter" ?!?,
; 205  :   //      maybe later combine them ?)
; 206  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN7@update_sta
$LN5@update_sta:
	mov	ecx, DWORD PTR _counter$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$3[ebp], ecx
$LN7@update_sta:
	cmp	DWORD PTR _counter$3[ebp], 5
	jge	SHORT $LN6@update_sta

; 207  :     if (state->guess[counter] == state->word[counter]) {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _counter$3[ebp]
	movsx	edx, BYTE PTR [edx+ecx]
	cmp	eax, edx
	jne	SHORT $LN11@update_sta

; 208  :       state->result[counter] = CORRECT;

	mov	eax, DWORD PTR _counter$3[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], 3

; 209  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	mov	BYTE PTR [edx+32], 1
$LN11@update_sta:

; 210  :     }
; 211  :   }

	jmp	SHORT $LN5@update_sta
$LN6@update_sta:

; 212  : 
; 213  :   // Now process every character that's there but not on the right position
; 214  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$2[ebp], 0
	jmp	SHORT $LN10@update_sta
$LN8@update_sta:
	mov	eax, DWORD PTR _counter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$2[ebp], eax
$LN10@update_sta:
	cmp	DWORD PTR _counter$2[ebp], 5
	jge	SHORT $LN9@update_sta

; 215  :     // if character is marked CORRECT, skip it
; 216  :     if (state->result[counter] == CORRECT) {

	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+ecx*4+12], 3
	jne	SHORT $LN12@update_sta

; 217  :       continue;    // next for-loop

	jmp	SHORT $LN8@update_sta
$LN12@update_sta:

; 218  :     }
; 219  :                             // call subfunction in this source and set result
; 220  :                             // (PRESENT/NOT_PRESENT) depending on bool return of subfunction
; 221  :     state->result[counter] = is_character_unmarked(state, state->guess[counter])

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$2[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_is_character_unmarked
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@update_sta
	mov	DWORD PTR tv141[ebp], 2
	jmp	SHORT $LN15@update_sta
$LN14@update_sta:
	mov	DWORD PTR tv141[ebp], 1
$LN15@update_sta:
	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 222  :       ? PRESENT
; 223  :       : NOT_PRESENT;
; 224  :   }

	jmp	SHORT $LN8@update_sta
$LN9@update_sta:

; 225  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_update_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_counter$1 = -8						; size = 4
_charfound$ = -1					; size = 1
_state$ = 8						; size = 4
_c$ = 12						; size = 1
_is_character_unmarked PROC

; 169  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 170  : #ifdef MYDEBUG
; 171  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	171					; 000000abH
	push	OFFSET $SG75295
	push	OFFSET $SG75296
	call	_printf
	add	esp, 12					; 0000000cH

; 172  : #endif
; 173  : 
; 174  :   bool charfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _charfound$[ebp], 0

; 175  : 
; 176  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@is_charact
$LN2@is_charact:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@is_charact:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@is_charact

; 177  :     if ( (state->word[counter] == c) && (state->used[counter] == false) ) {

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _counter$1[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN5@is_charact
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LN5@is_charact

; 178  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [edx+32], 1

; 179  :       charfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _charfound$[ebp], 1

; 180  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@is_charact
$LN5@is_charact:

; 181  :     }
; 182  :   }

	jmp	SHORT $LN2@is_charact
$LN3@is_charact:

; 183  :   return charfound;     // exit subfunction with scan results

	movzx	eax, BYTE PTR _charfound$[ebp]

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_is_character_unmarked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv94 = -12						; size = 4
_counter$1 = -8						; size = 4
_wordfound$ = -1					; size = 1
_word$ = 8						; size = 4
_word_is_allowed PROC

; 133  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 134  : #ifdef MYDEBUG
; 135  :   printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	135					; 00000087H
	push	OFFSET $SG75275
	push	OFFSET $SG75276
	call	_printf
	add	esp, 12					; 0000000cH

; 136  : #endif
; 137  : 
; 138  :   // Sequential search the guessed word in wordlist
; 139  :   bool wordfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _wordfound$[ebp], 0

; 140  :   for (int counter = 0; (words[counter] != NULL); ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@word_is_al
$LN2@word_is_al:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@word_is_al:
	mov	ecx, DWORD PTR _counter$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	SHORT $LN3@word_is_al

; 141  : #ifdef MYDEBUG
; 142  :     printf("\t#DBG %s@%d # strncmp [%s] with [%s]\n", __func__, __LINE__, word, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	push	142					; 0000008eH
	push	OFFSET $SG75277
	push	OFFSET $SG75278
	call	_printf
	add	esp, 20					; 00000014H

; 143  : #endif
; 144  :     if (strncmp(word, words[counter], WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN5@word_is_al

; 145  :       wordfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _wordfound$[ebp], 1

; 146  : #ifdef MYDEBUG
; 147  :       printf("\t#DBG %s@%d # found word %s\n", __func__, __LINE__, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	push	147					; 00000093H
	push	OFFSET $SG75280
	push	OFFSET $SG75281
	call	_printf
	add	esp, 16					; 00000010H

; 148  : #endif
; 149  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@word_is_al
$LN5@word_is_al:

; 150  :     }
; 151  :   }

	jmp	$LN2@word_is_al
$LN3@word_is_al:

; 152  : 
; 153  :   // Return the search result (true/false) to caller
; 154  : #ifdef MYDEBUG
; 155  :   printf("\t#DBG %s@%d # Returning with '%s'\n", __func__, __LINE__, wordfound ? "true" : "false");

	movzx	ecx, BYTE PTR _wordfound$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@word_is_al
	mov	DWORD PTR tv94[ebp], OFFSET $SG75282
	jmp	SHORT $LN8@word_is_al
$LN7@word_is_al:
	mov	DWORD PTR tv94[ebp], OFFSET $SG75283
$LN8@word_is_al:
	mov	edx, DWORD PTR tv94[ebp]
	push	edx
	push	155					; 0000009bH
	push	OFFSET $SG75284
	push	OFFSET $SG75285
	call	_printf
	add	esp, 16					; 00000010H

; 156  : #endif
; 157  :   return wordfound;

	movzx	eax, BYTE PTR _wordfound$[ebp]

; 158  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_word_is_allowed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 551  :         {

	push	ebp
	mov	ebp, esp

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 553  :         }

	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
