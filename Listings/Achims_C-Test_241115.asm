; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34433.0 

	TITLE	C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_fprintf
PUBLIC	_printf
PUBLIC	_word_is_allowed
PUBLIC	_is_character_unmarked
PUBLIC	_update_state
PUBLIC	_get_input
PUBLIC	_print_result
PUBLIC	_another_round
PUBLIC	_main
EXTRN	_isprint:PROC
EXTRN	_tolower:PROC
EXTRN	_strncmp:PROC
EXTRN	__imp__GetStdHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetConsoleMode@8:PROC
EXTRN	__imp__SetConsoleMode@8:PROC
EXTRN	_abort:PROC
EXTRN	_srand:PROC
EXTRN	_rand:PROC
EXTRN	_atoi:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_getopt:PROC
EXTRN	_getchar:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__time64:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_optind:DWORD
EXTRN	_optopt:DWORD
EXTRN	_optarg:DWORD
EXTRN	_words:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
_verbolvl DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG75308 DB	'word_is_allowed', 00H
$SG75309 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75311 DB	'word_is_allowed', 00H
$SG75312 DB	09H, '#DBG %s@%d # strncmp [%s] with [%s]', 0aH, 00H
	ORG $+2
$SG75315 DB	'word_is_allowed', 00H
$SG75316 DB	09H, '#DBG %s@%d # found word %s', 0aH, 00H
	ORG $+3
$SG75318 DB	'true', 00H
	ORG $+3
$SG75319 DB	'false', 00H
	ORG $+2
$SG75320 DB	'word_is_allowed', 00H
$SG75321 DB	09H, '#DBG %s@%d # Returning with ''%s''', 0aH, 00H
	ORG $+1
$SG75332 DB	'is_character_unmarked', 00H
	ORG $+2
$SG75333 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75351 DB	'update_state', 00H
	ORG $+3
$SG75352 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75371 DB	'get_input', 00H
	ORG $+2
$SG75372 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75373 DB	0aH, '%d. trial (#=exit) : ', 00H
	ORG $+1
$SG75378 DB	'get_input', 00H
	ORG $+2
$SG75379 DB	09H, '#DBG %s@%d # Input: [%s]', 0aH, 00H
	ORG $+1
$SG75382 DB	'Please enter exactly (!) %d characters !', 0aH, 00H
	ORG $+2
$SG75384 DB	'get_input', 00H
	ORG $+2
$SG75385 DB	09H, '#DBG %s@%d # Back from word_is_allowed', 0aH, 00H
	ORG $+3
$SG75388 DB	'Word not found in my wordlist', 0aH, 00H
	ORG $+1
$SG75389 DB	'Word found in my wordlist', 0aH, 00H
	ORG $+1
$SG75391 DB	'true', 00H
	ORG $+3
$SG75392 DB	'false', 00H
	ORG $+2
$SG75393 DB	'get_input', 00H
	ORG $+2
$SG75394 DB	09H, '#DBG %s@%d # badword is  %s', 0aH, 00H
	ORG $+2
$SG75396 DB	'get_input', 00H
	ORG $+2
$SG75397 DB	09H, '#DBG %s@%d # Leaving function', 0aH, 00H
$SG75408 DB	'print_result', 00H
	ORG $+3
$SG75409 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75410 DB	'! ', 00H
	ORG $+1
$SG75412 DB	01bH, '[37;42;1m', 00H
	ORG $+1
$SG75414 DB	01bH, '[37;43;1m', 00H
	ORG $+1
$SG75417 DB	01bH, '[37;41;1m', 00H
	ORG $+1
$SG75418 DB	'%c', 00H
	ORG $+1
$SG75419 DB	01bH, '[0m', 0aH, 00H
	ORG $+2
$SG75429 DB	'another_round', 00H
	ORG $+2
$SG75430 DB	09H, '#DBG %s@%d # Entering subfunction', 0aH, 00H
$SG75431 DB	'Another round ? [j/n] ', 00H
	ORG $+1
$SG75434 DB	0aH, 'OK, now go ahead...', 0aH, 00H
	ORG $+2
$SG75481 DB	'MSVC', 00H
	ORG $+3
$SG75482 DB	'18:36:29', 00H
	ORG $+3
$SG75483 DB	'Dec 30 2024', 00H
$SG75484 DB	'***** Running %s,', 0aH, 'Binary build date: %s @ %s by '
	DB	'%s %d *****', 0aH, 0aH, 00H
	ORG $+2
$SG75485 DB	0aH, 'Part %d : process commandline parameters by getopt.'
	DB	'c', 0aH, 00H
	ORG $+1
$SG75486 DB	'hf:v:c', 00H
	ORG $+5
$SG75488 DB	'Sample C programm derived from c''t wordle', 0aH, 'typed'
	DB	' in and modified by Achim Haag,', 0aH, 'see https://github.co'
	DB	'm/Achim-Haag/My_First_C_Program/blob/main/.vscode/tasks.json', 0aH
	DB	'derived from c''t 25/2024 (8.11.24), page 66 (https://github.'
	DB	'com/607011/wordle-c)', 0aH, 'Allowed commandline parameters:', 0aH
	DB	'-h : this help', 0aH, '-v <verbosity-level> : debugging', 0aH
	DB	'-f <number> : constant random number sequence for debugging', 0aH
	DB	'-c : show the word to guess in advance (just for debugging ;-'
	DB	')', 00H
	ORG $+3
$SG75490 DB	'Verbosity set to %s', 0aH, 00H
	ORG $+3
$SG75491 DB	'verbosity = %d (from string [%s])', 0aH, 00H
	ORG $+1
$SG75494 DB	'Verbosity level allowed from 1...9. Bye !', 0aH, 00H
	ORG $+1
$SG75496 DB	'Random generater value from parameter is %s', 0aH, 00H
	ORG $+3
$SG75497 DB	'Random generator value set to fixed number %d ... you''r'
	DB	'e debugging or a cheater ?!?', 0aH, 00H
	ORG $+3
$SG75499 DB	'Cheating the word is enabled (%d)', 0aH, 00H
	ORG $+1
$SG75503 DB	'Option -%c requires an argument. Try -h !', 0aH, 00H
	ORG $+1
$SG75506 DB	'Unknown option `-%c''. Try -h !', 0aH, 00H
$SG75507 DB	'Unknown option character `\x%x'', try -h ! Bye', 0aH, 00H
	ORG $+1
$SG75509 DB	'Parameter %c not handled, contact programmer !', 00H
	ORG $+1
$SG75511 DB	'main', 00H
	ORG $+3
$SG75512 DB	09H, '#DBG %s@%d # Unprocessed commmandline parameters (%'
	DB	'd parameters):', 0aH, 00H
$SG75513 DB	'main', 00H
	ORG $+3
$SG75514 DB	09H, '#DBG %s@%d # Non-option argument [%s]', 0aH, 00H
$SG75515 DB	0aH, 'Part %d : enable ANSI colors in windows terminal', 0aH
	DB	00H
	ORG $+1
$SG75517 DB	'Cannot get handle for standard device (STD_OUTPUT_HANDLE'
	DB	'), GetStdHandle RC=%d', 00H
	ORG $+2
$SG75519 DB	'Cannot get console mode, GetConsoleMode RC=%d', 00H
	ORG $+2
$SG75521 DB	'Cannot set console mode to virt. terminal proc., SetCons'
	DB	'oleMode RC=%d', 00H
	ORG $+2
$SG75522 DB	0aH, 'Part %d :  Now the quiz, here we go...', 0aH, 00H
	ORG $+3
$SG75524 DB	'Initial random generator seed: %d', 0aH, 00H
	ORG $+1
$SG75525 DB	0aH, 'NERD WORD', 0aH, 0aH, 'Guess the word with %d chara'
	DB	'cters in no more than %d trials.', 0aH, '(Abort = Ctrl+C - or'
	DB	' simply the hash key ''#'')', 0aH, 00H
$SG75527 DB	'true', 00H
	ORG $+3
$SG75528 DB	'false', 00H
	ORG $+2
$SG75529 DB	'main', 00H
	ORG $+3
$SG75530 DB	09H, '#DBG %s@%d # Entering while-loop, keepRunning is %s'
	DB	0aH, 00H
	ORG $+2
$SG75532 DB	'main', 00H
	ORG $+3
$SG75533 DB	09H, '#DBG %s@%d # Calling game_state', 0aH, 00H
	ORG $+2
$SG75535 DB	'main', 00H
	ORG $+3
$SG75536 DB	09H, '#DBG %s@%d # Table word count is %d', 0aH, 00H
	ORG $+2
$SG75538 DB	'main', 00H
	ORG $+3
$SG75539 DB	09H, '#DBG %s@%d # Hint: you''re guessing for [%s]', 0aH, 00H
	ORG $+2
$SG75541 DB	'main', 00H
	ORG $+3
$SG75542 DB	09H, '#DBG %s@%d # Entering for-loop, state.n_tries is %d'
	DB	0aH, 00H
	ORG $+2
$SG75544 DB	'main', 00H
	ORG $+3
$SG75545 DB	09H, '#DBG %s@%d # Calling get_input', 0aH, 00H
	ORG $+3
$SG75549 DB	'main', 00H
	ORG $+3
$SG75550 DB	09H, '#DBG %s@%d # Calling update_state', 0aH, 00H
$SG75553 DB	0aH, 'Yee-haw, you''ve won after %d. trials!', 0aH, 00H
$SG75555 DB	'You don''t guess the word, it was %s.', 0aH, 00H
	ORG $+2
$SG75557 DB	'main', 00H
	ORG $+3
$SG75558 DB	09H, '#DBG %s@%d # keepRunning after get_input', 0aH, 00H
	ORG $+1
$SG75560 DB	'true', 00H
	ORG $+3
$SG75561 DB	'false', 00H
	ORG $+2
$SG75562 DB	'main', 00H
	ORG $+3
$SG75563 DB	09H, '#DBG %s@%d # Bottom of while-loop, keepRunning is %'
	DB	's', 0aH, 00H
	ORG $+1
$SG75564 DB	0aH, 'Waiting...please press the -Enter- key (or do somet'
	DB	'hing with WinDBG ;-)', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	0dH
	DD	0659H
voltbl	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_opterr$ = -112						; size = 4
_endkey$ = -108						; size = 4
tv313 = -104						; size = 4
tv211 = -100						; size = 4
_seed$ = -96						; size = 4
tv197 = -92						; size = 4
_hOut$ = -88						; size = 4
_fixrandomseed$ = -84					; size = 4
_dwMode$ = -80						; size = 4
_index$1 = -76						; size = 4
_cmdline_arg$ = -72					; size = 4
_verbosity$ = -68					; size = 4
tv79 = -64						; size = 4
_num_words$2 = -60					; size = 4
_LastError$ = -56					; size = 4
_doRestart$3 = -51					; size = 1
_cheatword$ = -50					; size = 1
_keepRunning$ = -49					; size = 1
_state$4 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 404  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 405  : 
; 406  : 
; 407  : /*
; 408  :   To be sure, I run the least compiled .exe:
; 409  :   #pragma message: print filename (source) and compile/build date/time and compiler with version (simple decimal)
; 410  :   printf : print filename (.exe) and  compile/build date/time and compiler with version when running this program
; 411  : */
; 412  : 
; 413  : // Building with Microsoft Visual-C
; 414  : #if _MSC_VER          // see https://learn.microsoft.com/en-us/cpp/overview/compiler-versions?view=msvc-170
; 415  : #define COMP_TYP "MSVC"
; 416  : #define COMP_VER _MSC_FULL_VER
; 417  : // Building with gcc
; 418  : #elif __GNUC__		// see https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
; 419  : #define COMP_TYP "gcc"
; 420  : #define COMP_VER (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
; 421  : // Building with whatever
; 422  : #else
; 423  : #define COMP_TYP "???"
; 424  : #define COMP_VER 0
; 425  : #endif
; 426  : 
; 427  : #pragma message ("***** Build " __FILE__ " at " __DATE__ " " __TIME__ "*****\n")   
; 428  :   printf("***** Running %s,\nBinary build date: %s @ %s by %s %d *****\n\n", \

	push	194234433				; 0b93c841H
	push	OFFSET $SG75481
	push	OFFSET $SG75482
	push	OFFSET $SG75483
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	push	OFFSET $SG75484
	call	_printf
	add	esp, 24					; 00000018H

; 429  : 		  argv[0], __DATE__, __TIME__, COMP_TYP, COMP_VER);
; 430  : 
; 431  : /*
; 432  :   Process commandline parameters with Windows-specific getopt.c
; 433  :   getopt is a well-known function in the Unix environment and shells to parse argument lists,
; 434  :   see https://en.wikipedia.org/wiki/Getopt 
; 435  :   or https://www.gnu.org/software/libc/manual/html_node/Example-of-Getopt.html (the sample I used here)
; 436  :   The "main" function has to be defined with arguments "(int argc, char** argv)" (char** is a pointer to a pointer list)
; 437  : */
; 438  :   printf("\nPart %d : process commandline parameters by getopt.c\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	1
	push	OFFSET $SG75485
	call	_printf
	add	esp, 8

; 439  :   char *verbosity = NULL;   // Parameter "-v <number>", number = 1 : lowest verbosity

	mov	DWORD PTR _verbosity$[ebp], 0

; 440  :   int fixrandomseed = 0;    // Parameter "-f <number>" : init random generater with debugging number (otherwise with time stamp)

	mov	DWORD PTR _fixrandomseed$[ebp], 0

; 441  :   bool cheatword = false;   // Parameter "-c" : show each word to guess in advance

	mov	BYTE PTR _cheatword$[ebp], 0

; 442  : 
; 443  : /*
; 444  :   Variables defined for and by getopt.c (https://www.gnu.org/software/libc/manual/html_node/Using-Getopt.html)
; 445  :   Call : getopt(int argc, char* const *argv, const char* options)
; 446  :   argc = number of parameters in argv,
; 447  :   argv = pointer to pointerlist (i.e. to a pointer array), each pointer in pointerlist points to a commandline parameter
; 448  :   options = string with allowed commandline parameters. Colon after parameter means: parameter must have a following string value
; 449  : */  
; 450  :   int cmdline_arg = 0;      // Returns the next commandline parameter from getopt prefixed by "-", else a value of -1

	mov	DWORD PTR _cmdline_arg$[ebp], 0

; 451  :   int opterr = 0;           // getopt.c behaviour regarding error handling; 0 = silent but return "?" in case of error", not 0 = print msg

	mov	DWORD PTR _opterr$[ebp], 0
$LN2@main:

; 452  :   // int optopt in getopt.h     commandline parameter not specified in third parameter of getopt call, i.e. parameter not allowed
; 453  :   // int optind in getopt.h     set by getopt.c to the index of the next elemnt in argv. At end: points to first unprocessed argv element
; 454  :   // char* optarg in getopt.h   set by getopt.c to the option value behind the processed commandline parameter (e.g. "1" for "-v 1")
; 455  : 
; 456  : /* Now parse the given-to-main commandline parameters */
; 457  : /* Implemented: "-h" = help; "-v <number>" = verbosity with level (1=lowest); -f = fixed random generator value (NULL)*/
; 458  : /* The colon after an option requests a value behind an option character */
; 459  :   while ((cmdline_arg = getopt (argc, argv, "hf:v:c")) != -1) {

	push	OFFSET $SG75486
	mov	ecx, DWORD PTR _argv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argc$[ebp]
	push	edx
	call	_getopt
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _cmdline_arg$[ebp], eax
	cmp	DWORD PTR _cmdline_arg$[ebp], -1
	je	$LN3@main

; 460  :     // As we don't have here a valid verbolvl, I leave this debugging statement as comment:
; 461  :     // printf("### Entering next getopts loop (while), cmdline_arg = %d = %c\n", cmdline_arg, cmdline_arg);
; 462  :     switch (cmdline_arg) {

	mov	eax, DWORD PTR _cmdline_arg$[ebp]
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	sub	ecx, 63					; 0000003fH
	mov	DWORD PTR tv79[ebp], ecx
	cmp	DWORD PTR tv79[ebp], 55			; 00000037H
	ja	$LN31@main
	mov	edx, DWORD PTR tv79[ebp]
	movzx	eax, BYTE PTR $LN58@main[edx]
	jmp	DWORD PTR $LN59@main[eax*4]
$LN20@main:

; 463  :       case 'h':                     // Option -h -> Help
; 464  :         printf("Sample C programm derived from c't wordle\n"

	push	OFFSET $SG75488
	call	_printf
	add	esp, 4

; 465  :              "typed in and modified by Achim Haag,\n"
; 466  :              "see https://github.com/Achim-Haag/My_First_C_Program/blob/main/.vscode/tasks.json\n"
; 467  :              "derived from c't 25/2024 (8.11.24), page 66 (https://github.com/607011/wordle-c)\n"
; 468  :              "Allowed commandline parameters:\n"
; 469  :              "-h : this help\n"
; 470  :              "-v <verbosity-level> : debugging\n"
; 471  :              "-f <number> : constant random number sequence for debugging\n"
; 472  :              "-c : show the word to guess in advance (just for debugging ;-)");
; 473  :         return 1; // !!! Attention !!! Early return to OS

	mov	eax, 1
	jmp	$LN1@main

; 474  :         break;    // Never reached because of return

	jmp	$LN4@main
$LN21@main:

; 475  :       case 'v':                     // Option -v -> Verbosity, must be followed by a number (level of verbosity)
; 476  :         verbosity = optarg;   // Defined by getopt.h, returned from getopt

	mov	ecx, DWORD PTR _optarg
	mov	DWORD PTR _verbosity$[ebp], ecx

; 477  :         printf("Verbosity set to %s\n", verbosity);

	mov	edx, DWORD PTR _verbosity$[ebp]
	push	edx
	push	OFFSET $SG75490
	call	_printf
	add	esp, 8

; 478  :         // Convert verbosity string to integer
; 479  :         verbolvl=atoi(verbosity);

	mov	eax, DWORD PTR _verbosity$[ebp]
	push	eax
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _verbolvl, eax

; 480  :         printf ("verbosity = %d (from string [%s])\n", verbolvl, verbosity);

	mov	ecx, DWORD PTR _verbosity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _verbolvl
	push	edx
	push	OFFSET $SG75491
	call	_printf
	add	esp, 12					; 0000000cH

; 481  :         if (verbolvl < 1 || verbolvl > 9) {

	cmp	DWORD PTR _verbolvl, 1
	jl	SHORT $LN23@main
	cmp	DWORD PTR _verbolvl, 9
	jle	SHORT $LN22@main
$LN23@main:

; 482  :           printf("Verbosity level allowed from 1...9. Bye !\n");

	push	OFFSET $SG75494
	call	_printf
	add	esp, 4

; 483  :           return 8; // !!! Attention !!! Early return to OS

	mov	eax, 8
	jmp	$LN1@main

; 484  :           break;    // Never reached because of abort

	jmp	$LN4@main
$LN22@main:

; 485  :         }
; 486  :         break;

	jmp	$LN4@main
$LN24@main:

; 487  :       case 'f':                     // Option -f -> Fixed random number
; 488  :         printf("Random generater value from parameter is %s\n",(char*) optarg); // Casting optarg not necessary but seems good practice

	mov	eax, DWORD PTR _optarg
	push	eax
	push	OFFSET $SG75496
	call	_printf
	add	esp, 8

; 489  :         fixrandomseed=atoi(optarg);

	mov	ecx, DWORD PTR _optarg
	push	ecx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _fixrandomseed$[ebp], eax

; 490  :         printf("Random generator value set to fixed number %d ... you're debugging or a cheater ?!?\n", fixrandomseed);

	mov	edx, DWORD PTR _fixrandomseed$[ebp]
	push	edx
	push	OFFSET $SG75497
	call	_printf
	add	esp, 8

; 491  :         break;

	jmp	$LN4@main
$LN25@main:

; 492  :       case 'c':                     // Option -f -> Fixed random number
; 493  :         cheatword = true;

	mov	BYTE PTR _cheatword$[ebp], 1

; 494  :         printf("Cheating the word is enabled (%d)\n", cheatword);

	movzx	eax, BYTE PTR _cheatword$[ebp]
	push	eax
	push	OFFSET $SG75499
	call	_printf
	add	esp, 8

; 495  :         break;

	jmp	$LN4@main
$LN26@main:

; 496  :       case '?':                     // Any other commandline parameter error
; 497  :         if (optopt == 'v') {         // optopt: Parameter in error, here -v without following number

	cmp	DWORD PTR _optopt, 118			; 00000076H
	jne	SHORT $LN27@main

; 498  :           fprintf (stderr, "Option -%c requires an argument. Try -h !\n", optopt);

	mov	ecx, DWORD PTR _optopt
	push	ecx
	push	OFFSET $SG75503
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN30@main
$LN27@main:

; 499  :         } else if (isprint (optopt)) {    // here we found a parameter not specified in the third getopt argument (string, see above)

	mov	edx, DWORD PTR _optopt
	push	edx
	call	_isprint
	add	esp, 4
	test	eax, eax
	je	SHORT $LN29@main

; 500  :           fprintf (stderr, "Unknown option `-%c'. Try -h !\n", optopt);

	mov	eax, DWORD PTR _optopt
	push	eax
	push	OFFSET $SG75506
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 501  :         } else {                    // Any other getopt error - exit program

	jmp	SHORT $LN30@main
$LN29@main:

; 502  :           fprintf (stderr, "Unknown option character `\\x%x', try -h ! Bye\n", optopt);

	mov	ecx, DWORD PTR _optopt
	push	ecx
	push	OFFSET $SG75507
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH
$LN30@main:

; 503  :         } // endif
; 504  :         return 1; // !!! Attention !!! Early return to OS

	mov	eax, 1
	jmp	$LN1@main

; 505  :         break;    // Never reached because of return

	jmp	SHORT $LN4@main
$LN31@main:

; 506  :       default:                      // Parameter allowed but not handled - this should not occur
; 507  :         printf("Parameter %c not handled, contact programmer !", cmdline_arg);

	mov	edx, DWORD PTR _cmdline_arg$[ebp]
	push	edx
	push	OFFSET $SG75509
	call	_printf
	add	esp, 8

; 508  :         abort (); // !!! Attention !!! Early return to OS

	call	_abort
	npad	1
$LN4@main:

; 509  :         break;    // Never reached because of abort
; 510  :     }
; 511  :   }

	jmp	$LN2@main
$LN3@main:

; 512  : 
; 513  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN7@main

; 514  :     printf("\t#DBG %s@%d # Unprocessed commmandline parameters (%d parameters):\n", __func__, __LINE__, optind);

	mov	eax, DWORD PTR _optind
	push	eax
	push	514					; 00000202H
	push	OFFSET $SG75511
	push	OFFSET $SG75512
	call	_printf
	add	esp, 16					; 00000010H

; 515  :     for (int index = optind; index < argc; index++) printf ("\t#DBG %s@%d # Non-option argument [%s]\n", __func__, __LINE__, argv[index]);

	mov	ecx, DWORD PTR _optind
	mov	DWORD PTR _index$1[ebp], ecx
	jmp	SHORT $LN8@main
$LN6@main:
	mov	edx, DWORD PTR _index$1[ebp]
	add	edx, 1
	mov	DWORD PTR _index$1[ebp], edx
$LN8@main:
	mov	eax, DWORD PTR _index$1[ebp]
	cmp	eax, DWORD PTR _argc$[ebp]
	jge	SHORT $LN7@main
	mov	ecx, DWORD PTR _index$1[ebp]
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	push	515					; 00000203H
	push	OFFSET $SG75513
	push	OFFSET $SG75514
	call	_printf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN6@main
$LN7@main:

; 516  :   }
; 517  : 
; 518  : /*
; 519  :   To enable ANSI text formatting in Windows cmd.exe, I had to add some extra code in my environment (W10 22H2)
; 520  :   Stolen from https://learn.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences#example-of-select-anniversary-update-features
; 521  :   Chapter "Samples" - "Example of SGR terminal sequences"
; 522  : */
; 523  : 
; 524  : #if _MSC_VER          // Necessary only in Windows environment as bash should know ANSI by default
; 525  : 
; 526  : /*
; 527  :   Enable Windows 10 cmd.exe ANSI processing
; 528  : */
; 529  :   printf("\nPart %d : enable ANSI colors in windows terminal\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	2
	push	OFFSET $SG75515
	call	_printf
	add	esp, 8

; 530  :   // Set output mode to handle virtual terminal sequences
; 531  :   DWORD LastError = 0;          // Keep GetLastError in own variable to not interfere with printf

	mov	DWORD PTR _LastError$[ebp], 0

; 532  :   HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);

	push	-11					; fffffff5H
	call	DWORD PTR __imp__GetStdHandle@4
	mov	DWORD PTR _hOut$[ebp], eax

; 533  :   if (hOut == INVALID_HANDLE_VALUE)   {

	cmp	DWORD PTR _hOut$[ebp], -1
	jne	SHORT $LN33@main

; 534  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 535  :     printf("Cannot get handle for standard device (STD_OUTPUT_HANDLE), GetStdHandle RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75517
	call	_printf
	add	esp, 8

; 536  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN33@main:

; 537  :   }
; 538  : 
; 539  :   DWORD dwMode = 0;

	mov	DWORD PTR _dwMode$[ebp], 0

; 540  :   if (!GetConsoleMode(hOut, &dwMode)) {

	lea	edx, DWORD PTR _dwMode$[ebp]
	push	edx
	mov	eax, DWORD PTR _hOut$[ebp]
	push	eax
	call	DWORD PTR __imp__GetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN34@main

; 541  :     LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 542  :     printf ("Cannot get console mode, GetConsoleMode RC=%d", LastError);

	mov	ecx, DWORD PTR _LastError$[ebp]
	push	ecx
	push	OFFSET $SG75519
	call	_printf
	add	esp, 8

; 543  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN34@main:

; 544  :   }
; 545  : 
; 546  :   dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;

	mov	edx, DWORD PTR _dwMode$[ebp]
	or	edx, 4
	mov	DWORD PTR _dwMode$[ebp], edx

; 547  :   if (!SetConsoleMode(hOut, dwMode)) {

	mov	eax, DWORD PTR _dwMode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOut$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetConsoleMode@8
	test	eax, eax
	jne	SHORT $LN35@main

; 548  :    LastError = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _LastError$[ebp], eax

; 549  :     printf("Cannot set console mode to virt. terminal proc., SetConsoleMode RC=%d", LastError);

	mov	edx, DWORD PTR _LastError$[ebp]
	push	edx
	push	OFFSET $SG75521
	call	_printf
	add	esp, 8

; 550  :     return LastError; // !!! Attention !!! Early return to OS

	mov	eax, DWORD PTR _LastError$[ebp]
	jmp	$LN1@main
$LN35@main:

; 551  :   }
; 552  : 
; 553  : /*    In sample, but unused here
; 554  : 
; 555  :     // Try some Set Graphics Rendition (SGR) terminal escape sequences
; 556  :     wprintf(L"\x1b[31mThis text has a red foreground using SGR.31.\r\n");
; 557  :     wprintf(L"\x1b[1mThis text has a bright (bold) red foreground using SGR.1 to affect the previous color setting.\r\n");
; 558  :     wprintf(L"\x1b[mThis text has returned to default colors using SGR.0 implicitly.\r\n");
; 559  :     wprintf(L"\x1b[34;46mThis text shows the foreground and background change at the same time.\r\n");
; 560  :     wprintf(L"\x1b[0mThis text has returned to default colors using SGR.0 explicitly.\r\n");
; 561  :     wprintf(L"\x1b[31;32;33;34;35;36;101;102;103;104;105;106;107mThis text attempts to apply many colors in the same command. Note the colors are applied from left to right so only the right-most option of foreground cyan (SGR.36) and background bright white (SGR.107) is effective.\r\n");
; 562  :     wprintf(L"\x1b[39mThis text has restored the foreground color only.\r\n");
; 563  :     wprintf(L"\x1b[49mThis text has restored the background color only.\r\n");
; 564  : 
; 565  :     return 0;
; 566  : */
; 567  : 
; 568  : #endif    // End Windows ANSI enabling section 
; 569  : 
; 570  : 
; 571  : /************************* TEST END *************************** */
; 572  : 
; 573  : 
; 574  :   printf("\nPart %d :  Now the quiz, here we go...\n",  (__COUNTER__ + 1)); // Misuse precompiler __COUNTER__ for heading line

	push	3
	push	OFFSET $SG75522
	call	_printf
	add	esp, 8

; 575  : 
; 576  : /*
; 577  :     The following "ternary operator" replaces an if/then/else clause.
; 578  :     Question mark is "then", colon is "else".
; 579  :     If the number of parameters given to this program (including argument 1 = Path+Filename of this program)
; 580  :     is greater than 1, an argument is given explicitly and determins the "random seed".
; 581  :     This eases testing as for a specific initial random seed the random generator returns the same series of numbers
; 582  :     If no explicit parameter is specified, the actual timestamp is used for the initialization of the random generater,
; 583  :     leading to nonpredictable random number series.
; 584  : */
; 585  :   unsigned int seed = (fixrandomseed != 0)

	cmp	DWORD PTR _fixrandomseed$[ebp], 0
	je	SHORT $LN52@main
	mov	eax, DWORD PTR _fixrandomseed$[ebp]
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN53@main
$LN52@main:
	push	0
	call	_time
	add	esp, 4
	mov	DWORD PTR tv197[ebp], eax
$LN53@main:
	mov	ecx, DWORD PTR tv197[ebp]
	mov	DWORD PTR _seed$[ebp], ecx

; 586  :                       ? (unsigned int)fixrandomseed
; 587  :                       : (unsigned int)time(NULL) ;
; 588  : 
; 589  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN36@main

; 590  :     printf("Initial random generator seed: %d\n", seed);

	mov	edx, DWORD PTR _seed$[ebp]
	push	edx
	push	OFFSET $SG75524
	call	_printf
	add	esp, 8
$LN36@main:

; 591  :   }
; 592  : 
; 593  : /*
; 594  :     Prepare the random number generation for later use of the "rand" function
; 595  : */
; 596  :   srand(seed);

	mov	eax, DWORD PTR _seed$[ebp]
	push	eax
	call	_srand
	add	esp, 4

; 597  : 
; 598  :   printf("\nNERD WORD\n\n"

	push	6
	push	5
	push	OFFSET $SG75525
	call	_printf
	add	esp, 12					; 0000000cH

; 599  :          "Guess the word with %d characters in no more than %d trials.\n"
; 600  :          "(Abort = Ctrl+C - or simply the hash key '#')\n",
; 601  :          WORD_LENGTH, MAX_TRIES);
; 602  : 
; 603  : /*
; 604  :     We run this program until the user aborts.
; 605  :     we cannot see at this moment, how this decision is made, but we know, 
; 606  :     it must made by setting keepRunning to it's logical value "false".
; 607  : */
; 608  :   bool keepRunning = true;

	mov	BYTE PTR _keepRunning$[ebp], 1
$LN9@main:

; 609  :   while (keepRunning) {

	movzx	ecx, BYTE PTR _keepRunning$[ebp]
	test	ecx, ecx
	je	$LN10@main

; 610  : 
; 611  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN37@main

; 612  :       printf("\t#DBG %s@%d # Entering while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	edx, BYTE PTR _keepRunning$[ebp]
	test	edx, edx
	je	SHORT $LN54@main
	mov	DWORD PTR tv211[ebp], OFFSET $SG75527
	jmp	SHORT $LN55@main
$LN54@main:
	mov	DWORD PTR tv211[ebp], OFFSET $SG75528
$LN55@main:
	mov	eax, DWORD PTR tv211[ebp]
	push	eax
	push	612					; 00000264H
	push	OFFSET $SG75529
	push	OFFSET $SG75530
	call	_printf
	add	esp, 16					; 00000010H
$LN37@main:

; 613  :     }
; 614  : 
; 615  : 
; 616  : /*
; 617  :     First of all create a "real instance" of type game_state, it's name is "state"
; 618  :     It's a structure combining multiple elements in storage (here we need our RAM ;-)
; 619  :     The layout of the structure is defined above as a typeset "game_state"
; 620  :     so "game_state" is - from a higher point of view - the same as an integer, character, string, whatever
; 621  :     But...as far as I think, it's no "executable" statement, it just reserves memory in it's scope
; 622  :     (the compiler generates code to allocate RAM)
; 623  :     Btw: scope means here: "main"
; 624  : */
; 625  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN38@main

; 626  :       printf("\t#DBG %s@%d # Calling game_state\n", __func__, __LINE__);

	push	626					; 00000272H
	push	OFFSET $SG75532
	push	OFFSET $SG75533
	call	_printf
	add	esp, 12					; 0000000cH
$LN38@main:

; 627  :     }
; 628  :     game_state state;
; 629  : 
; 630  : /*
; 631  :     Count all words in the wordlist (until we reach a null pointer element)
; 632  : */
; 633  :     int num_words;
; 634  :     for (num_words = 0; words[num_words] != NULL; num_words++) {};  // One-line loop

	mov	DWORD PTR _num_words$2[ebp], 0
	jmp	SHORT $LN13@main
$LN11@main:
	mov	ecx, DWORD PTR _num_words$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _num_words$2[ebp], ecx
$LN13@main:
	mov	edx, DWORD PTR _num_words$2[ebp]
	cmp	DWORD PTR _words[edx*4], 0
	je	SHORT $LN12@main
	jmp	SHORT $LN11@main
$LN12@main:

; 635  : 
; 636  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN39@main

; 637  :       printf("\t#DBG %s@%d # Table word count is %d\n", __func__, __LINE__, num_words);

	mov	eax, DWORD PTR _num_words$2[ebp]
	push	eax
	push	637					; 0000027dH
	push	OFFSET $SG75535
	push	OFFSET $SG75536
	call	_printf
	add	esp, 16					; 00000010H
$LN39@main:

; 638  :      }
; 639  : 
; 640  : /*
; 641  :     Now we fill one variable - the pointer to the word - with the address of a randomly selected
; 642  :     word of our wordlist (that comes out of words.c which is linked together with this program)
; 643  :     Important: as the word in array "words" is addressed by modulo (%) NUM_WORDS,
; 644  :     NUM_WORDS must not be higher than the real number of words in the array "words",
; 645  :     else something unpredictable would occur
; 646  :     (maybe NUM_WORDS should be defined near "words" if this is possible ?)
; 647  :     Debugging: the other variables in structure "state" are undefined at the first entry into the loop
; 648  : */
; 649  :     state.word = words[rand() % num_words];

	call	_rand
	cdq
	idiv	DWORD PTR _num_words$2[ebp]
	mov	ecx, DWORD PTR _words[edx*4]
	mov	DWORD PTR _state$4[ebp], ecx

; 650  : 
; 651  : /*
; 652  :     only for testing: show me the selected word
; 653  :     #-marked statements are processed by the compilers preprocessor
; 654  :     (personally, I call it precompiler in memoriam to PL/I ;-)
; 655  :     To activate this printf, a compiler option "-D DEBUG" must be given that defines DEBUG (no value needed)
; 656  :     Not to be confused with _DEBUG (underscore !) that is defined by MSVC by the /MTd or /MDd option,
; 657  :     see https://learn.microsoft.com/en-us/cpp/c-runtime-library/debug?view=msvc-170
; 658  :     Changed to my own precompiler variable MYDEBUG for simplicity
; 659  :     Changed from precompiler variable MYDEBUG to commandline parameter -v <verbolvl> (verbolvl=1..9)
; 660  : */
; 661  :     if ( cheatword ) {    // not dependend on debugging but on commandline parameter -c (Cheat ;-)

	movzx	edx, BYTE PTR _cheatword$[ebp]
	test	edx, edx
	je	SHORT $LN40@main

; 662  :       printf("\t#DBG %s@%d # Hint: you're guessing for [%s]\n", __func__, __LINE__, state.word);

	mov	eax, DWORD PTR _state$4[ebp]
	push	eax
	push	662					; 00000296H
	push	OFFSET $SG75538
	push	OFFSET $SG75539
	call	_printf
	add	esp, 16					; 00000010H
$LN40@main:

; 663  :     }
; 664  : 
; 665  : /*
; 666  :   Now we run another loop that asks our guesses of the characters
; 667  :   The for loop counts a number variable from a starting point to an ending point
; 668  :   In the C language, the ending point doesn't has to be dependend on the number variable alone,
; 669  :   it can be extended by other logical expressions
; 670  : */
; 671  :     bool doRestart = false;

	mov	BYTE PTR _doRestart$3[ebp], 0

; 672  :     for (state.n_tries = 1; 

	mov	DWORD PTR _state$4[ebp+40], 1
	jmp	SHORT $LN16@main
$LN14@main:

; 674  :          ++state.n_tries)    {

	mov	ecx, DWORD PTR _state$4[ebp+40]
	add	ecx, 1
	mov	DWORD PTR _state$4[ebp+40], ecx
$LN16@main:

; 673  :          state.n_tries <= MAX_TRIES && !doRestart;

	cmp	DWORD PTR _state$4[ebp+40], 6
	jg	$LN15@main
	movzx	edx, BYTE PTR _doRestart$3[ebp]
	test	edx, edx
	jne	$LN15@main

; 675  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN41@main

; 676  :         printf("\t#DBG %s@%d # Entering for-loop, state.n_tries is %d\n", __func__, __LINE__, state.n_tries);

	mov	eax, DWORD PTR _state$4[ebp+40]
	push	eax
	push	676					; 000002a4H
	push	OFFSET $SG75541
	push	OFFSET $SG75542
	call	_printf
	add	esp, 16					; 00000010H
$LN41@main:

; 677  :       }
; 678  :     
; 679  : /*
; 680  :     we call the above defined function to get user's input.
; 681  :     The "&" means: give the address of variable (structure) "state" to this function,
; 682  :     so this function is able to modify this structure - i.e. the structure's variables
; 683  : */   
; 684  : 
; 685  :     // ask user for keyboard input, exit loop if user wants to
; 686  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN42@main

; 687  :         printf("\t#DBG %s@%d # Calling get_input\n", __func__, __LINE__);

	push	687					; 000002afH
	push	OFFSET $SG75544
	push	OFFSET $SG75545
	call	_printf
	add	esp, 12					; 0000000cH
$LN42@main:

; 688  :       }
; 689  : 
; 690  :       if (get_input(&state)) {

	lea	ecx, DWORD PTR _state$4[ebp]
	push	ecx
	call	_get_input
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	$LN43@main

; 691  :     // process user's input
; 692  :         if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN45@main

; 693  :           printf("\t#DBG %s@%d # Calling update_state\n", __func__, __LINE__);

	push	693					; 000002b5H
	push	OFFSET $SG75549
	push	OFFSET $SG75550
	call	_printf
	add	esp, 12					; 0000000cH
$LN45@main:

; 694  :         }
; 695  :         update_state(&state);

	lea	eax, DWORD PTR _state$4[ebp]
	push	eax
	call	_update_state
	add	esp, 4

; 696  : 
; 697  :       // show results
; 698  :         print_result(&state);

	lea	ecx, DWORD PTR _state$4[ebp]
	push	ecx
	call	_print_result
	add	esp, 4

; 699  : 
; 700  :       // Compare input word with word to guess, if equal, user wins
; 701  :         if (strncmp(state.guess, state.word, WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _state$4[ebp]
	push	edx
	lea	eax, DWORD PTR _state$4[ebp+4]
	push	eax
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN46@main

; 702  :           printf ("\nYee-haw, you've won after %d. trials!\n", state.n_tries);

	mov	ecx, DWORD PTR _state$4[ebp+40]
	push	ecx
	push	OFFSET $SG75553
	call	_printf
	add	esp, 8

; 703  :           doRestart = true;

	mov	BYTE PTR _doRestart$3[ebp], 1

; 704  :           keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al

; 705  :         }

	jmp	SHORT $LN48@main
$LN46@main:

; 706  :         else {
; 707  :           if (state.n_tries == MAX_TRIES) {

	cmp	DWORD PTR _state$4[ebp+40], 6
	jne	SHORT $LN48@main

; 708  :             printf("You don't guess the word, it was %s.\n", state.word);

	mov	edx, DWORD PTR _state$4[ebp]
	push	edx
	push	OFFSET $SG75555
	call	_printf
	add	esp, 8

; 709  :             keepRunning = another_round();

	call	_another_round
	mov	BYTE PTR _keepRunning$[ebp], al
$LN48@main:

; 710  :           }
; 711  :         }
; 712  :         
; 713  :       }

	jmp	SHORT $LN44@main
$LN43@main:

; 714  :       else {
; 715  :         keepRunning = false;

	mov	BYTE PTR _keepRunning$[ebp], 0

; 716  :         if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN49@main

; 717  :           printf("\t#DBG %s@%d # keepRunning after get_input\n", __func__, __LINE__), keepRunning;

	push	717					; 000002cdH
	push	OFFSET $SG75557
	push	OFFSET $SG75558
	call	_printf
	add	esp, 12					; 0000000cH
$LN49@main:

; 718  :         }
; 719  :         break; // for-loop

	jmp	SHORT $LN15@main
$LN44@main:

; 720  :       }
; 721  : 
; 722  :     } // end "for num_words" loop

	jmp	$LN14@main
$LN15@main:

; 723  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN50@main

; 724  :       printf("\t#DBG %s@%d # Bottom of while-loop, keepRunning is %s\n", __func__, __LINE__, keepRunning ? "true" : "false");

	movzx	eax, BYTE PTR _keepRunning$[ebp]
	test	eax, eax
	je	SHORT $LN56@main
	mov	DWORD PTR tv313[ebp], OFFSET $SG75560
	jmp	SHORT $LN57@main
$LN56@main:
	mov	DWORD PTR tv313[ebp], OFFSET $SG75561
$LN57@main:
	mov	ecx, DWORD PTR tv313[ebp]
	push	ecx
	push	724					; 000002d4H
	push	OFFSET $SG75562
	push	OFFSET $SG75563
	call	_printf
	add	esp, 16					; 00000010H
$LN50@main:

; 725  :     }
; 726  :   } // end "while (keepRunning)" loop

	jmp	$LN9@main
$LN10@main:

; 727  :   printf("\nWaiting...please press the -Enter- key (or do something with WinDBG ;-)\n");

	push	OFFSET $SG75564
	call	_printf
	add	esp, 4
$LN19@main:

; 728  :   int endkey;
; 729  :   do {
; 730  :     endkey = getchar();

	call	_getchar
	mov	DWORD PTR _endkey$[ebp], eax

; 731  :   } while (endkey != '\n');    // Clear keybd buffer and wait for Enter

	cmp	DWORD PTR _endkey$[ebp], 10		; 0000000aH
	jne	SHORT $LN19@main

; 732  : 
; 733  : // Return to OS
; 734  :   return EXIT_SUCCESS;

	xor	eax, eax
$LN1@main:

; 735  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN59@main:
	DD	$LN26@main
	DD	$LN25@main
	DD	$LN24@main
	DD	$LN20@main
	DD	$LN21@main
	DD	$LN31@main
$LN58@main:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	5
	DB	5
	DB	2
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv83 = -12						; size = 4
tv81 = -8						; size = 4
_yes$ = -2						; size = 1
_answer$ = -1						; size = 1
_another_round PROC

; 381  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 382  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN4@another_ro

; 383  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	383					; 0000017fH
	push	OFFSET $SG75429
	push	OFFSET $SG75430
	call	_printf
	add	esp, 12					; 0000000cH
$LN4@another_ro:

; 384  :   }
; 385  : 
; 386  :   printf("Another round ? [j/n] ");

	push	OFFSET $SG75431
	call	_printf
	add	esp, 4

; 387  :   char answer = (char)tolower(getchar()) ; // read pressed key from keyboard

	call	_getchar
	push	eax
	call	_tolower
	add	esp, 4
	mov	BYTE PTR _answer$[ebp], al

; 388  :   // drop superfluous characters
; 389  :   if (answer != '\n') {

	movsx	eax, BYTE PTR _answer$[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
$LN2@another_ro:

; 390  :     while (getchar() != '\n') ;   // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@another_ro
	jmp	SHORT $LN2@another_ro
$LN3@another_ro:

; 391  :   }
; 392  :   bool yes = ((answer == 'j') || (answer == '\n')) ;

	movsx	ecx, BYTE PTR _answer$[ebp]
	cmp	ecx, 106				; 0000006aH
	je	SHORT $LN8@another_ro
	movsx	edx, BYTE PTR _answer$[ebp]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN8@another_ro
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN9@another_ro
$LN8@another_ro:
	mov	DWORD PTR tv81[ebp], 1
$LN9@another_ro:
	cmp	DWORD PTR tv81[ebp], 0
	jne	SHORT $LN10@another_ro
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN11@another_ro
$LN10@another_ro:
	mov	DWORD PTR tv83[ebp], 1
$LN11@another_ro:
	mov	al, BYTE PTR tv83[ebp]
	mov	BYTE PTR _yes$[ebp], al

; 393  :   if (yes) {

	movzx	ecx, BYTE PTR _yes$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@another_ro

; 394  :     printf("\nOK, now go ahead...\n");

	push	OFFSET $SG75434
	call	_printf
	add	esp, 4
$LN6@another_ro:

; 395  :   }
; 396  :   return yes;

	movzx	eax, BYTE PTR _yes$[ebp]

; 397  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_another_round ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv74 = -8						; size = 4
_counter$1 = -4						; size = 4
_state$ = 8						; size = 4
_print_result PROC

; 342  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 343  : 
; 344  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN7@print_resu

; 345  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	345					; 00000159H
	push	OFFSET $SG75408
	push	OFFSET $SG75409
	call	_printf
	add	esp, 12					; 0000000cH
$LN7@print_resu:

; 346  :   }
; 347  :   // Show result in a nice way (ANSI escape sequences for coloring)
; 348  :   // Explanation see http://jafrog.com/2013/11/23/colors-in-terminal.html
; 349  :   // or https://ss64.com/nt/syntax-ansi.html
; 350  :   // Hint: \033 (3*8+3=27) is an octal representation of 0x1B (dec 27 = ESC)
; 351  :   printf("! ");

	push	OFFSET $SG75410
	call	_printf
	add	esp, 4

; 352  : 
; 353  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@print_resu
$LN2@print_resu:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@print_resu:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@print_resu

; 354  :     switch (state->result[counter]) {

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 1
	je	SHORT $LN10@print_resu
	cmp	DWORD PTR tv74[ebp], 2
	je	SHORT $LN9@print_resu
	cmp	DWORD PTR tv74[ebp], 3
	je	SHORT $LN8@print_resu
	jmp	SHORT $LN10@print_resu
$LN8@print_resu:

; 355  :       case CORRECT:
; 356  :         // Characters in the right position marked with green background
; 357  :         printf("\033[37;42;1m");  // ESC writen as octal number (3*8+3 = 27)

	push	OFFSET $SG75412
	call	_printf
	add	esp, 4

; 358  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN9@print_resu:

; 359  :       case PRESENT:
; 360  :         // Characters in word but wrong positioned marked with yellow background
; 361  :         printf("\x1b[37;43;1m");   // ESC writen as hexadecimal number (1*16 + 11 = 27)

	push	OFFSET $SG75414
	call	_printf
	add	esp, 4

; 362  :         break; // break ends this switch-part

	jmp	SHORT $LN5@print_resu
$LN10@print_resu:

; 363  :       case NOT_PRESENT:
; 364  :         // Characters not in word not marked at all, but:
; 365  :         // since there is no "break"-Statement, they are processd
; 366  :         // by the following "default:" branch
; 367  :         // In short: "case NOT_PRESENT" and "default:" refers to the same code
; 368  :       default:    // the "else" branch of this switch-statement
; 369  :         // Characters not in word marked with red background
; 370  :         // Characters not in word marked with red background
; 371  :         printf("\033[37;41;1m");

	push	OFFSET $SG75417
	call	_printf
	add	esp, 4
$LN5@print_resu:

; 372  :         break; // break ends this switch-part
; 373  :     }
; 374  :     printf("%c", state->guess[counter]);

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _counter$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	push	edx
	push	OFFSET $SG75418
	call	_printf
	add	esp, 8

; 375  :   }

	jmp	SHORT $LN2@print_resu
$LN3@print_resu:

; 376  :   // Reset font and background colors to their defaults
; 377  :   printf("\033[0m\n");

	push	OFFSET $SG75419
	call	_printf
	add	esp, 4

; 378  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_print_result ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv157 = -12						; size = 4
_charin$1 = -8						; size = 4
_bad_word$ = -1						; size = 1
_state$ = 8						; size = 4
_get_input PROC

; 265  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 266  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN12@get_input

; 267  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	267					; 0000010bH
	push	OFFSET $SG75371
	push	OFFSET $SG75372
	call	_printf
	add	esp, 12					; 0000000cH
$LN12@get_input:

; 268  :   }
; 269  : 
; 270  :   // loop until user input ok
; 271  :   bool bad_word;
; 272  :   do {      // while (bad_word)
; 273  :     printf("\n%d. trial (#=exit) : ", state->n_tries);

	mov	eax, DWORD PTR _state$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	push	OFFSET $SG75373
	call	_printf
	add	esp, 8

; 274  :     // read input from console (WORD_LENGTH characters)
; 275  :     bad_word = false;

	mov	BYTE PTR _bad_word$[ebp], 0

; 276  :     for (int charin = 0; charin < WORD_LENGTH; charin++) {

	mov	DWORD PTR _charin$1[ebp], 0
	jmp	SHORT $LN7@get_input
$LN5@get_input:
	mov	edx, DWORD PTR _charin$1[ebp]
	add	edx, 1
	mov	DWORD PTR _charin$1[ebp], edx
$LN7@get_input:
	cmp	DWORD PTR _charin$1[ebp], 5
	jge	SHORT $LN6@get_input

; 277  :       state->guess[charin] = getchar();         // read character from console

	call	_getchar
	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [ecx+4], al

; 278  :   
; 279  :       if (state->guess[charin] == '#') {         // Asterisk means exit program

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _charin$1[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN13@get_input
$LN8@get_input:

; 280  :         while (getchar() != '\n') {};           // // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN9@get_input
	jmp	SHORT $LN8@get_input
$LN9@get_input:

; 281  :         return false;

	xor	al, al
	jmp	$LN1@get_input
$LN13@get_input:

; 282  :       }
; 283  :       if (state->guess[charin] == '\n') {       // Enter means end-of-input1

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, DWORD PTR _charin$1[ebp]
	movsx	edx, BYTE PTR [ecx+4]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN14@get_input

; 284  :         state->guess[charin] = '\0';

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _charin$1[ebp]
	mov	BYTE PTR [eax+4], 0

; 285  :         bad_word = true;

	mov	BYTE PTR _bad_word$[ebp], 1

; 286  :         break;    // exit for-loop

	jmp	SHORT $LN6@get_input
$LN14@get_input:

; 287  :       } 
; 288  :     }

	jmp	SHORT $LN5@get_input
$LN6@get_input:

; 289  :     // read (and drop) remaining characters (after the WORD_LENGTH one) using a while-loop
; 290  :     if (!bad_word) {

	movzx	ecx, BYTE PTR _bad_word$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@get_input
$LN10@get_input:

; 291  :       while (getchar() != '\n') {};         // Clear keybd buffer and wait for Enter

	call	_getchar
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN11@get_input
	jmp	SHORT $LN10@get_input
$LN11@get_input:

; 292  :     }
; 293  : 
; 294  :     // set end of string to char after WORD_LENGTH
; 295  :     state->guess[WORD_LENGTH] = '\0';

	mov	edx, 1
	imul	eax, edx, 5
	mov	ecx, DWORD PTR _state$[ebp]
	mov	BYTE PTR [ecx+eax+4], 0

; 296  : 
; 297  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN16@get_input

; 298  :       printf("\t#DBG %s@%d # Input: [%s]\n", __func__, __LINE__, state->guess);

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, 4
	push	edx
	push	298					; 0000012aH
	push	OFFSET $SG75378
	push	OFFSET $SG75379
	call	_printf
	add	esp, 16					; 00000010H
$LN16@get_input:

; 299  :     }
; 300  : 
; 301  :     // process incorrect user input
; 302  :     if (bad_word) {

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN17@get_input

; 303  :       printf("Please enter exactly (!) %d characters !\n", WORD_LENGTH);

	push	5
	push	OFFSET $SG75382
	call	_printf
	add	esp, 8

; 304  :     }

	jmp	SHORT $LN21@get_input
$LN17@get_input:

; 305  :     else {
; 306  : /*    
; 307  :   Deactivated the following two statements as we get only character hints if we hit a word from the wordlist
; 308  :   So if one doesn't know the wordlist, guessing is nearly impossible
; 309  : 	    bad_word = !word_is_allowed(state->guess);
; 310  : 	    if (bad_word)
; 311  : */      
; 312  : 
; 313  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN19@get_input

; 314  :         printf("\t#DBG %s@%d # Back from word_is_allowed\n", __func__, __LINE__);

	push	314					; 0000013aH
	push	OFFSET $SG75384
	push	OFFSET $SG75385
	call	_printf
	add	esp, 12					; 0000000cH
$LN19@get_input:

; 315  :       }
; 316  :       if (!word_is_allowed(state->guess)) {

	mov	ecx, DWORD PTR _state$[ebp]
	add	ecx, 4
	push	ecx
	call	_word_is_allowed
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN20@get_input

; 317  :         printf("Word not found in my wordlist\n");

	push	OFFSET $SG75388
	call	_printf
	add	esp, 4

; 318  :       }

	jmp	SHORT $LN21@get_input
$LN20@get_input:

; 319  :       else {
; 320  :         printf("Word found in my wordlist\n");

	push	OFFSET $SG75389
	call	_printf
	add	esp, 4
$LN21@get_input:

; 321  :       }
; 322  : 
; 323  :     }
; 324  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN22@get_input

; 325  :       printf("\t#DBG %s@%d # badword is  %s\n", __func__, __LINE__, bad_word ? "true" : "false");

	movzx	eax, BYTE PTR _bad_word$[ebp]
	test	eax, eax
	je	SHORT $LN25@get_input
	mov	DWORD PTR tv157[ebp], OFFSET $SG75391
	jmp	SHORT $LN26@get_input
$LN25@get_input:
	mov	DWORD PTR tv157[ebp], OFFSET $SG75392
$LN26@get_input:
	mov	ecx, DWORD PTR tv157[ebp]
	push	ecx
	push	325					; 00000145H
	push	OFFSET $SG75393
	push	OFFSET $SG75394
	call	_printf
	add	esp, 16					; 00000010H
$LN22@get_input:

; 326  :     }
; 327  : 
; 328  :   } while (bad_word) ;   // end "do ... while" loop

	movzx	edx, BYTE PTR _bad_word$[ebp]
	test	edx, edx
	jne	$LN12@get_input

; 329  : 
; 330  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN23@get_input

; 331  :     printf("\t#DBG %s@%d # Leaving function\n", __func__, __LINE__);

	push	331					; 0000014bH
	push	OFFSET $SG75396
	push	OFFSET $SG75397
	call	_printf
	add	esp, 12					; 0000000cH
$LN23@get_input:

; 332  :   }
; 333  : 
; 334  :   return true;

	mov	al, 1
$LN1@get_input:

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_get_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv142 = -16						; size = 4
_counter$1 = -12					; size = 4
_counter$2 = -8						; size = 4
_counter$3 = -4						; size = 4
_state$ = 8						; size = 4
_update_state PROC

; 224  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 225  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN11@update_sta

; 226  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	226					; 000000e2H
	push	OFFSET $SG75351
	push	OFFSET $SG75352
	call	_printf
	add	esp, 12					; 0000000cH
$LN11@update_sta:

; 227  :   }
; 228  :  
; 229  :   // mark every character as "unmarked" before we process the input
; 230  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@update_sta
$LN2@update_sta:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@update_sta:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@update_sta

; 231  :     state->result[counter] = UNMARKED;

	mov	ecx, DWORD PTR _counter$1[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [edx+ecx*4+12], 0

; 232  :     state->used[counter] = false;

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [eax+32], 0

; 233  :   }

	jmp	SHORT $LN2@update_sta
$LN3@update_sta:

; 234  : 
; 235  :   // find correct characters and mark then
; 236  :   // (Btw: I don't understand, why this and the upper loop aren't combined ?
; 237  :   //      there's no reference to other array elements than "counter" ?!?,
; 238  :   //      maybe later combine them ?)
; 239  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$3[ebp], 0
	jmp	SHORT $LN7@update_sta
$LN5@update_sta:
	mov	ecx, DWORD PTR _counter$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _counter$3[ebp], ecx
$LN7@update_sta:
	cmp	DWORD PTR _counter$3[ebp], 5
	jge	SHORT $LN6@update_sta

; 240  :     if (state->guess[counter] == state->word[counter]) {

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	movsx	eax, BYTE PTR [edx+4]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _counter$3[ebp]
	movsx	edx, BYTE PTR [edx+ecx]
	cmp	eax, edx
	jne	SHORT $LN12@update_sta

; 241  :       state->result[counter] = CORRECT;

	mov	eax, DWORD PTR _counter$3[ebp]
	mov	ecx, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx+eax*4+12], 3

; 242  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$3[ebp]
	mov	BYTE PTR [edx+32], 1
$LN12@update_sta:

; 243  :     }
; 244  :   }

	jmp	SHORT $LN5@update_sta
$LN6@update_sta:

; 245  : 
; 246  :   // Now process every character that's there but not on the right position
; 247  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$2[ebp], 0
	jmp	SHORT $LN10@update_sta
$LN8@update_sta:
	mov	eax, DWORD PTR _counter$2[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$2[ebp], eax
$LN10@update_sta:
	cmp	DWORD PTR _counter$2[ebp], 5
	jge	SHORT $LN9@update_sta

; 248  :     // if character is marked CORRECT, skip it
; 249  :     if (state->result[counter] == CORRECT) {

	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	cmp	DWORD PTR [edx+ecx*4+12], 3
	jne	SHORT $LN13@update_sta

; 250  :       continue;    // next for-loop

	jmp	SHORT $LN8@update_sta
$LN13@update_sta:

; 251  :     }
; 252  :                             // call subfunction in this source and set result
; 253  :                             // (PRESENT/NOT_PRESENT) depending on bool return of subfunction
; 254  :     state->result[counter] = is_character_unmarked(state, state->guess[counter])

	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$2[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _state$[ebp]
	push	edx
	call	_is_character_unmarked
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN15@update_sta
	mov	DWORD PTR tv142[ebp], 2
	jmp	SHORT $LN16@update_sta
$LN15@update_sta:
	mov	DWORD PTR tv142[ebp], 1
$LN16@update_sta:
	mov	ecx, DWORD PTR _counter$2[ebp]
	mov	edx, DWORD PTR _state$[ebp]
	mov	eax, DWORD PTR tv142[ebp]
	mov	DWORD PTR [edx+ecx*4+12], eax

; 255  :       ? PRESENT
; 256  :       : NOT_PRESENT;
; 257  :   }

	jmp	SHORT $LN8@update_sta
$LN9@update_sta:

; 258  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_update_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
_counter$1 = -8						; size = 4
_charfound$ = -1					; size = 1
_state$ = 8						; size = 4
_c$ = 12						; size = 1
_is_character_unmarked PROC

; 202  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 203  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN5@is_charact

; 204  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	204					; 000000ccH
	push	OFFSET $SG75332
	push	OFFSET $SG75333
	call	_printf
	add	esp, 12					; 0000000cH
$LN5@is_charact:

; 205  :   }
; 206  : 
; 207  :   bool charfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _charfound$[ebp], 0

; 208  : 
; 209  :   for (int counter = 0; counter < WORD_LENGTH; ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@is_charact
$LN2@is_charact:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@is_charact:
	cmp	DWORD PTR _counter$1[ebp], 5
	jge	SHORT $LN3@is_charact

; 210  :     if ( (state->word[counter] == c) && (state->used[counter] == false) ) {

	mov	ecx, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _counter$1[ebp]
	movsx	ecx, BYTE PTR [edx+eax]
	movsx	edx, BYTE PTR _c$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN6@is_charact
	mov	eax, DWORD PTR _state$[ebp]
	add	eax, DWORD PTR _counter$1[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	jne	SHORT $LN6@is_charact

; 211  :       state->used[counter] = true;

	mov	edx, DWORD PTR _state$[ebp]
	add	edx, DWORD PTR _counter$1[ebp]
	mov	BYTE PTR [edx+32], 1

; 212  :       charfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _charfound$[ebp], 1

; 213  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@is_charact
$LN6@is_charact:

; 214  :     }
; 215  :   }

	jmp	SHORT $LN2@is_charact
$LN3@is_charact:

; 216  :   return charfound;     // exit subfunction with scan results

	movzx	eax, BYTE PTR _charfound$[ebp]

; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_is_character_unmarked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\Achims_C-Test_241115.c
_TEXT	SEGMENT
tv130 = -12						; size = 4
_counter$1 = -8						; size = 4
_wordfound$ = -1					; size = 1
_word$ = 8						; size = 4
_word_is_allowed PROC

; 166  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 167  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN5@word_is_al

; 168  :     printf("\t#DBG %s@%d # Entering subfunction\n", __func__, __LINE__);

	push	168					; 000000a8H
	push	OFFSET $SG75308
	push	OFFSET $SG75309
	call	_printf
	add	esp, 12					; 0000000cH
$LN5@word_is_al:

; 169  :   }
; 170  : 
; 171  :   // Sequential search the guessed word in wordlist
; 172  :   bool wordfound = false;    // Assume we will not find any character of user's input

	mov	BYTE PTR _wordfound$[ebp], 0

; 173  :   for (int counter = 0; (words[counter] != NULL); ++counter) {

	mov	DWORD PTR _counter$1[ebp], 0
	jmp	SHORT $LN4@word_is_al
$LN2@word_is_al:
	mov	eax, DWORD PTR _counter$1[ebp]
	add	eax, 1
	mov	DWORD PTR _counter$1[ebp], eax
$LN4@word_is_al:
	mov	ecx, DWORD PTR _counter$1[ebp]
	cmp	DWORD PTR _words[ecx*4], 0
	je	$LN3@word_is_al

; 174  :     if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN6@word_is_al

; 175  :       printf("\t#DBG %s@%d # strncmp [%s] with [%s]\n", __func__, __LINE__, word, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	push	175					; 000000afH
	push	OFFSET $SG75311
	push	OFFSET $SG75312
	call	_printf
	add	esp, 20					; 00000014H
$LN6@word_is_al:

; 176  :     }
; 177  :     if (strncmp(word, words[counter], WORD_LENGTH) == 0) {

	push	5
	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	mov	ecx, DWORD PTR _word$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@word_is_al

; 178  :       wordfound = true;   // Wow, we have found a character in our word that user guessed !

	mov	BYTE PTR _wordfound$[ebp], 1

; 179  :       if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN8@word_is_al

; 180  :         printf("\t#DBG %s@%d # found word %s\n", __func__, __LINE__, words[counter]);

	mov	edx, DWORD PTR _counter$1[ebp]
	mov	eax, DWORD PTR _words[edx*4]
	push	eax
	push	180					; 000000b4H
	push	OFFSET $SG75315
	push	OFFSET $SG75316
	call	_printf
	add	esp, 16					; 00000010H
$LN8@word_is_al:

; 181  :       }
; 182  :       break;  // exit for-loop immediately

	jmp	SHORT $LN3@word_is_al
$LN7@word_is_al:

; 183  :     }
; 184  :   }

	jmp	$LN2@word_is_al
$LN3@word_is_al:

; 185  : 
; 186  :   // Return the search result (true/false) to caller
; 187  :   if ( verbolvl > 0 ) {

	cmp	DWORD PTR _verbolvl, 0
	jle	SHORT $LN9@word_is_al

; 188  :     printf("\t#DBG %s@%d # Returning with '%s'\n", __func__, __LINE__, wordfound ? "true" : "false");

	movzx	ecx, BYTE PTR _wordfound$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@word_is_al
	mov	DWORD PTR tv130[ebp], OFFSET $SG75318
	jmp	SHORT $LN12@word_is_al
$LN11@word_is_al:
	mov	DWORD PTR tv130[ebp], OFFSET $SG75319
$LN12@word_is_al:
	mov	edx, DWORD PTR tv130[ebp]
	push	edx
	push	188					; 000000bcH
	push	OFFSET $SG75320
	push	OFFSET $SG75321
	call	_printf
	add	esp, 16					; 00000010H
$LN9@word_is_al:

; 189  :   }
; 190  :   return wordfound;

	movzx	eax, BYTE PTR _wordfound$[ebp]

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_word_is_allowed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\time.h
_TEXT	SEGMENT
__Time$ = 8						; size = 4
_time	PROC

; 551  :         {

	push	ebp
	mov	ebp, esp

; 552  :             return _time64(_Time);

	mov	eax, DWORD PTR __Time$[ebp]
	push	eax
	call	__time64
	add	esp, 4

; 553  :         }

	pop	ebp
	ret	0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	1
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 844  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
