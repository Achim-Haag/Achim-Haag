; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34433.0 

	TITLE	C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_optind
PUBLIC	_optopt
PUBLIC	_opterr
_DATA	SEGMENT
COMM	___mingw_optreset:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG74460 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_optarg:DWORD
_DATA	ENDS
_DATA	SEGMENT
_optind	DD	01H
_optopt	DD	03fH
_opterr	DD	01H
_DATA	ENDS
CONST	SEGMENT
_recargchar DB	'option requires an argument -- %c', 00H
	ORG $+2
_recargstring DB 'option requires an argument -- %s', 00H
	ORG $+2
_ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+3
_noarg	DB	'option doesn''t take an argument -- %.*s', 00H
_illoptchar DB	'unknown option -- %c', 00H
	ORG $+3
_illoptstring DB 'unknown option -- %s', 00H
CONST	ENDS
PUBLIC	_getopt
PUBLIC	_getopt_long
PUBLIC	_getopt_long_only
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_vfprintf
PUBLIC	_fprintf
EXTRN	___p___argv:PROC
EXTRN	_getenv:PROC
EXTRN	_strchr:PROC
EXTRN	_strlen:PROC
EXTRN	_strncmp:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG74625 DB	01H DUP (?)
$SG74631 DB	01H DUP (?)
$SG74639 DB	01H DUP (?)
$SG74647 DB	01H DUP (?)
$SG74659 DB	01H DUP (?)
$SG74661 DB	01H DUP (?)
$SG74670 DB	01H DUP (?)
$SG74672 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_place	DD	FLAT:$SG74460
_nonopt_start DD 0ffffffffH
_nonopt_end DD	0ffffffffH
$SG74477 DB	'%s: ', 00H
	ORG $+3
$SG74479 DB	0aH, 00H
	ORG $+2
?posixly_correct@?1??getopt_internal@@9@9 DD 0ffffffffH	; `getopt_internal'::`2'::posixly_correct
$SG74614 DB	'POSIXLY_CORRECT', 00H
_DATA	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_ap$ = -4						; size = 4
_fmt$ = 8						; size = 4
_warnx	PROC

; 131  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 132  :   va_list ap;
; 133  :   va_start(ap,fmt);

	lea	eax, DWORD PTR _fmt$[ebp+4]
	mov	DWORD PTR _ap$[ebp], eax

; 134  :   _vwarnx(fmt,ap);

	mov	ecx, DWORD PTR _ap$[ebp]
	push	ecx
	mov	edx, DWORD PTR _fmt$[ebp]
	push	edx
	call	__vwarnx
	add	esp, 8

; 135  :   va_end(ap);

	mov	DWORD PTR _ap$[ebp], 0

; 136  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_warnx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_ap$ = 12						; size = 4
__vwarnx PROC

; 122  : {

	push	ebp
	mov	ebp, esp

; 123  :   (void)fprintf(stderr,"%s: ",__progname);

	call	___p___argv
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	OFFSET $SG74477
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 12					; 0000000cH

; 124  :   if (fmt != NULL)

	cmp	DWORD PTR _fmt$[ebp], 0
	je	SHORT $LN2@vwarnx

; 125  :     (void)vfprintf(stderr,fmt,ap);

	mov	edx, DWORD PTR _ap$[ebp]
	push	edx
	mov	eax, DWORD PTR _fmt$[ebp]
	push	eax
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_vfprintf
	add	esp, 12					; 0000000cH
$LN2@vwarnx:

; 126  :   (void)fprintf(stderr,"\n");

	push	OFFSET $SG74479
	push	2
	call	___acrt_iob_func
	add	esp, 4
	push	eax
	call	_fprintf
	add	esp, 8

; 127  : }

	pop	ebp
	ret	0
__vwarnx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_swap$ = -36						; size = 4
_cyclelen$ = -32					; size = 4
_nopts$ = -28						; size = 4
_nnonopts$ = -24					; size = 4
_ncycle$ = -20						; size = 4
_cstart$ = -16						; size = 4
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_pos$ = -4						; size = 4
_panonopt_start$ = 8					; size = 4
_panonopt_end$ = 12					; size = 4
_opt_end$ = 16						; size = 4
_nargv$ = 20						; size = 4
_permute_args PROC

; 164  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi

; 165  : 	int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 166  : 	char *swap;
; 167  : 
; 168  : 	/*
; 169  : 	 * compute lengths of blocks and number and size of cycles
; 170  : 	 */
; 171  : 	nnonopts = panonopt_end - panonopt_start;

	mov	eax, DWORD PTR _panonopt_end$[ebp]
	sub	eax, DWORD PTR _panonopt_start$[ebp]
	mov	DWORD PTR _nnonopts$[ebp], eax

; 172  : 	nopts = opt_end - panonopt_end;

	mov	ecx, DWORD PTR _opt_end$[ebp]
	sub	ecx, DWORD PTR _panonopt_end$[ebp]
	mov	DWORD PTR _nopts$[ebp], ecx

; 173  : 	ncycle = gcd(nnonopts, nopts);

	mov	edx, DWORD PTR _nopts$[ebp]
	push	edx
	mov	eax, DWORD PTR _nnonopts$[ebp]
	push	eax
	call	_gcd
	add	esp, 8
	mov	DWORD PTR _ncycle$[ebp], eax

; 174  : 	cyclelen = (opt_end - panonopt_start) / ncycle;

	mov	eax, DWORD PTR _opt_end$[ebp]
	sub	eax, DWORD PTR _panonopt_start$[ebp]
	cdq
	idiv	DWORD PTR _ncycle$[ebp]
	mov	DWORD PTR _cyclelen$[ebp], eax

; 175  : 
; 176  : 	for (i = 0; i < ncycle; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@permute_ar
$LN2@permute_ar:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN4@permute_ar:
	mov	edx, DWORD PTR _i$[ebp]
	cmp	edx, DWORD PTR _ncycle$[ebp]
	jge	SHORT $LN3@permute_ar

; 177  : 		cstart = panonopt_end+i;

	mov	eax, DWORD PTR _panonopt_end$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _cstart$[ebp], eax

; 178  : 		pos = cstart;

	mov	ecx, DWORD PTR _cstart$[ebp]
	mov	DWORD PTR _pos$[ebp], ecx

; 179  : 		for (j = 0; j < cyclelen; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@permute_ar
$LN5@permute_ar:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@permute_ar:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _cyclelen$[ebp]
	jge	SHORT $LN6@permute_ar

; 180  : 			if (pos >= panonopt_end)

	mov	ecx, DWORD PTR _pos$[ebp]
	cmp	ecx, DWORD PTR _panonopt_end$[ebp]
	jl	SHORT $LN8@permute_ar

; 181  : 				pos -= nnonopts;

	mov	edx, DWORD PTR _pos$[ebp]
	sub	edx, DWORD PTR _nnonopts$[ebp]
	mov	DWORD PTR _pos$[ebp], edx
	jmp	SHORT $LN9@permute_ar
$LN8@permute_ar:

; 182  : 			else
; 183  : 				pos += nopts;

	mov	eax, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR _nopts$[ebp]
	mov	DWORD PTR _pos$[ebp], eax
$LN9@permute_ar:

; 184  : 			swap = nargv[pos];

	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _swap$[ebp], eax

; 185  : 			/* LINTED const cast */
; 186  : 			((char **) nargv)[pos] = nargv[cstart];

	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR _cstart$[ebp]
	mov	esi, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx*4], eax

; 187  : 			/* LINTED const cast */
; 188  : 			((char **)nargv)[cstart] = swap;

	mov	ecx, DWORD PTR _cstart$[ebp]
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR _swap$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 189  : 		}

	jmp	SHORT $LN5@permute_ar
$LN6@permute_ar:

; 190  : 	}

	jmp	$LN2@permute_ar
$LN3@permute_ar:

; 191  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_permute_args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_c$ = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_gcd	PROC

; 143  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 144  : 	int c;
; 145  : 
; 146  : 	c = a % b;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _b$[ebp]
	mov	DWORD PTR _c$[ebp], edx
$LN2@gcd:

; 147  : 	while (c != 0) {

	cmp	DWORD PTR _c$[ebp], 0
	je	SHORT $LN3@gcd

; 148  : 		a = b;

	mov	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 149  : 		b = c;

	mov	ecx, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], ecx

; 150  : 		c = a % b;

	mov	eax, DWORD PTR _a$[ebp]
	cdq
	idiv	DWORD PTR _b$[ebp]
	mov	DWORD PTR _c$[ebp], edx

; 151  : 	}

	jmp	SHORT $LN2@gcd
$LN3@gcd:

; 152  : 
; 153  : 	return (b);

	mov	eax, DWORD PTR _b$[ebp]

; 154  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_gcd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
tv213 = -32						; size = 4
tv176 = -28						; size = 4
_ambiguous$ = -24					; size = 4
_current_argv_len$ = -20				; size = 4
_has_equal$ = -16					; size = 4
_current_argv$ = -12					; size = 4
_i$ = -8						; size = 4
_match$ = -4						; size = 4
_nargv$ = 8						; size = 4
_options$ = 12						; size = 4
_long_options$ = 16					; size = 4
_idx$ = 20						; size = 4
_short_too$ = 24					; size = 4
_parse_long_options PROC

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 202  : 	char *current_argv, *has_equal;
; 203  : 	size_t current_argv_len;
; 204  : 	int i, ambiguous, match;
; 205  : 
; 206  : #define IDENTICAL_INTERPRETATION(_x, _y)                                \
; 207  : 	(long_options[(_x)].has_arg == long_options[(_y)].has_arg &&    \
; 208  : 	 long_options[(_x)].flag == long_options[(_y)].flag &&          \
; 209  : 	 long_options[(_x)].val == long_options[(_y)].val)
; 210  : 
; 211  : 	current_argv = place;

	mov	eax, DWORD PTR _place
	mov	DWORD PTR _current_argv$[ebp], eax

; 212  : 	match = -1;

	mov	DWORD PTR _match$[ebp], -1

; 213  : 	ambiguous = 0;

	mov	DWORD PTR _ambiguous$[ebp], 0

; 214  : 
; 215  : 	optind++;

	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx

; 216  : 
; 217  : 	if ((has_equal = strchr(current_argv, '=')) != NULL) {

	push	61					; 0000003dH
	mov	edx, DWORD PTR _current_argv$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _has_equal$[ebp], eax
	cmp	DWORD PTR _has_equal$[ebp], 0
	je	SHORT $LN5@parse_long

; 218  : 		/* argument found (--option=arg) */
; 219  : 		current_argv_len = has_equal - current_argv;

	mov	eax, DWORD PTR _has_equal$[ebp]
	sub	eax, DWORD PTR _current_argv$[ebp]
	mov	DWORD PTR _current_argv_len$[ebp], eax

; 220  : 		has_equal++;

	mov	ecx, DWORD PTR _has_equal$[ebp]
	add	ecx, 1
	mov	DWORD PTR _has_equal$[ebp], ecx

; 221  : 	} else

	jmp	SHORT $LN6@parse_long
$LN5@parse_long:

; 222  : 		current_argv_len = strlen(current_argv);

	mov	edx, DWORD PTR _current_argv$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _current_argv_len$[ebp], eax
$LN6@parse_long:

; 223  : 
; 224  : 	for (i = 0; long_options[i].name; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@parse_long
$LN2@parse_long:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@parse_long:
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [edx+ecx], 0
	je	$LN3@parse_long

; 225  : 		/* find matching long option */
; 226  : 		if (strncmp(current_argv, long_options[i].name,

	mov	eax, DWORD PTR _current_argv_len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	mov	ecx, DWORD PTR _current_argv$[ebp]
	push	ecx
	call	_strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@parse_long

; 227  : 		    current_argv_len))
; 228  : 			continue;

	jmp	SHORT $LN2@parse_long
$LN7@parse_long:

; 229  : 
; 230  : 		if (strlen(long_options[i].name) == current_argv_len) {

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, DWORD PTR _current_argv_len$[ebp]
	jne	SHORT $LN8@parse_long

; 231  : 			/* exact match */
; 232  : 			match = i;

	mov	edx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _match$[ebp], edx

; 233  : 			ambiguous = 0;

	mov	DWORD PTR _ambiguous$[ebp], 0

; 234  : 			break;

	jmp	SHORT $LN3@parse_long
$LN8@parse_long:

; 235  : 		}
; 236  : 		/*
; 237  : 		 * If this is a known short option, don't allow
; 238  : 		 * a partial match of a single character.
; 239  : 		 */
; 240  : 		if (short_too && current_argv_len == 1)

	cmp	DWORD PTR _short_too$[ebp], 0
	je	SHORT $LN9@parse_long
	cmp	DWORD PTR _current_argv_len$[ebp], 1
	jne	SHORT $LN9@parse_long

; 241  : 			continue;

	jmp	SHORT $LN2@parse_long
$LN9@parse_long:

; 242  : 
; 243  : 		if (match == -1)	/* partial match */

	cmp	DWORD PTR _match$[ebp], -1
	jne	SHORT $LN10@parse_long

; 244  : 			match = i;

	mov	eax, DWORD PTR _i$[ebp]
	mov	DWORD PTR _match$[ebp], eax
	jmp	SHORT $LN12@parse_long
$LN10@parse_long:

; 245  : 		else if (!IDENTICAL_INTERPRETATION(i, match))

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	mov	esi, DWORD PTR _long_options$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+4]
	cmp	ecx, DWORD PTR [esi+edx+4]
	jne	SHORT $LN13@parse_long
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	esi, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+edx+8]
	cmp	edx, DWORD PTR [esi+eax+8]
	jne	SHORT $LN13@parse_long
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _match$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	esi, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [edx+eax+12]
	cmp	eax, DWORD PTR [esi+ecx+12]
	je	SHORT $LN12@parse_long
$LN13@parse_long:

; 246  : 			ambiguous = 1;

	mov	DWORD PTR _ambiguous$[ebp], 1
$LN12@parse_long:

; 247  : 	}

	jmp	$LN2@parse_long
$LN3@parse_long:

; 248  : 	if (ambiguous) {

	cmp	DWORD PTR _ambiguous$[ebp], 0
	je	SHORT $LN14@parse_long

; 249  : 		/* ambiguous abbreviation */
; 250  : 		if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN15@parse_long
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN15@parse_long

; 251  : 			warnx(ambig, (int)current_argv_len,

	mov	eax, DWORD PTR _current_argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _current_argv_len$[ebp]
	push	ecx
	push	OFFSET _ambig
	call	_warnx
	add	esp, 12					; 0000000cH
$LN15@parse_long:

; 252  : 			     current_argv);
; 253  : 		optopt = 0;

	mov	DWORD PTR _optopt, 0

; 254  : 		return (BADCH);

	mov	eax, 63					; 0000003fH
	jmp	$LN35@parse_long
$LN14@parse_long:

; 255  : 	}
; 256  : 	if (match != -1) {		/* option found */

	cmp	DWORD PTR _match$[ebp], -1
	je	$LN16@parse_long

; 257  : 		if (long_options[match].has_arg == no_argument
; 258  : 		    && has_equal) {

	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [eax+edx+4], 0
	jne	$LN18@parse_long
	cmp	DWORD PTR _has_equal$[ebp], 0
	je	SHORT $LN18@parse_long

; 259  : 			if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN19@parse_long
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN19@parse_long

; 260  : 				warnx(noarg, (int)current_argv_len,

	mov	eax, DWORD PTR _current_argv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _current_argv_len$[ebp]
	push	ecx
	push	OFFSET _noarg
	call	_warnx
	add	esp, 12					; 0000000cH
$LN19@parse_long:

; 261  : 				     current_argv);
; 262  : 			/*
; 263  : 			 * XXX: GNU sets optopt to val regardless of flag
; 264  : 			 */
; 265  : 			if (long_options[match].flag == NULL)

	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [eax+edx+8], 0
	jne	SHORT $LN20@parse_long

; 266  : 				optopt = long_options[match].val;

	mov	ecx, DWORD PTR _match$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _optopt, eax
	jmp	SHORT $LN21@parse_long
$LN20@parse_long:

; 267  : 			else
; 268  : 				optopt = 0;

	mov	DWORD PTR _optopt, 0
$LN21@parse_long:

; 269  : 			return (BADARG);

	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN37@parse_long
	mov	DWORD PTR tv176[ebp], 58		; 0000003aH
	jmp	SHORT $LN38@parse_long
$LN37@parse_long:
	mov	DWORD PTR tv176[ebp], 63		; 0000003fH
$LN38@parse_long:
	mov	eax, DWORD PTR tv176[ebp]
	jmp	$LN35@parse_long
$LN18@parse_long:

; 270  : 		}
; 271  : 		if (long_options[match].has_arg == required_argument ||

	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+4], 1
	je	SHORT $LN23@parse_long
	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [eax+edx+4], 2
	jne	SHORT $LN26@parse_long
$LN23@parse_long:

; 272  : 		    long_options[match].has_arg == optional_argument) {
; 273  : 			if (has_equal)

	cmp	DWORD PTR _has_equal$[ebp], 0
	je	SHORT $LN24@parse_long

; 274  : 				optarg = has_equal;

	mov	ecx, DWORD PTR _has_equal$[ebp]
	mov	DWORD PTR _optarg, ecx
	jmp	SHORT $LN26@parse_long
$LN24@parse_long:

; 275  : 			else if (long_options[match].has_arg ==

	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [eax+edx+4], 1
	jne	SHORT $LN26@parse_long

; 276  : 			    required_argument) {
; 277  : 				/*
; 278  : 				 * optional argument doesn't use next nargv
; 279  : 				 */
; 280  : 				optarg = nargv[optind++];

	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _optarg, eax
	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx
$LN26@parse_long:

; 281  : 			}
; 282  : 		}
; 283  : 		if ((long_options[match].has_arg == required_argument)
; 284  : 		    && (optarg == NULL)) {

	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [eax+edx+4], 1
	jne	$LN27@parse_long
	cmp	DWORD PTR _optarg, 0
	jne	$LN27@parse_long

; 285  : 			/*
; 286  : 			 * Missing argument; leading ':' indicates no error
; 287  : 			 * should be generated.
; 288  : 			 */
; 289  : 			if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN28@parse_long
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN28@parse_long

; 290  : 				warnx(recargstring,

	mov	eax, DWORD PTR _current_argv$[ebp]
	push	eax
	push	OFFSET _recargstring
	call	_warnx
	add	esp, 8
$LN28@parse_long:

; 291  : 				    current_argv);
; 292  : 			/*
; 293  : 			 * XXX: GNU sets optopt to val regardless of flag
; 294  : 			 */
; 295  : 			if (long_options[match].flag == NULL)

	mov	ecx, DWORD PTR _match$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [edx+ecx+8], 0
	jne	SHORT $LN29@parse_long

; 296  : 				optopt = long_options[match].val;

	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _optopt, edx
	jmp	SHORT $LN30@parse_long
$LN29@parse_long:

; 297  : 			else
; 298  : 				optopt = 0;

	mov	DWORD PTR _optopt, 0
$LN30@parse_long:

; 299  : 			--optind;

	mov	eax, DWORD PTR _optind
	sub	eax, 1
	mov	DWORD PTR _optind, eax

; 300  : 			return (BADARG);

	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	jne	SHORT $LN39@parse_long
	mov	DWORD PTR tv213[ebp], 58		; 0000003aH
	jmp	SHORT $LN40@parse_long
$LN39@parse_long:
	mov	DWORD PTR tv213[ebp], 63		; 0000003fH
$LN40@parse_long:
	mov	eax, DWORD PTR tv213[ebp]
	jmp	$LN35@parse_long
$LN27@parse_long:

; 301  : 		}
; 302  : 	} else {			/* unknown option */

	jmp	SHORT $LN17@parse_long
$LN16@parse_long:

; 303  : 		if (short_too) {

	cmp	DWORD PTR _short_too$[ebp], 0
	je	SHORT $LN31@parse_long

; 304  : 			--optind;

	mov	eax, DWORD PTR _optind
	sub	eax, 1
	mov	DWORD PTR _optind, eax

; 305  : 			return (-1);

	or	eax, -1
	jmp	$LN35@parse_long
$LN31@parse_long:

; 306  : 		}
; 307  : 		if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN32@parse_long
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN32@parse_long

; 308  : 			warnx(illoptstring, current_argv);

	mov	eax, DWORD PTR _current_argv$[ebp]
	push	eax
	push	OFFSET _illoptstring
	call	_warnx
	add	esp, 8
$LN32@parse_long:

; 309  : 		optopt = 0;

	mov	DWORD PTR _optopt, 0

; 310  : 		return (BADCH);

	mov	eax, 63					; 0000003fH
	jmp	SHORT $LN35@parse_long
$LN17@parse_long:

; 311  : 	}
; 312  : 	if (idx)

	cmp	DWORD PTR _idx$[ebp], 0
	je	SHORT $LN33@parse_long

; 313  : 		*idx = match;

	mov	ecx, DWORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _match$[ebp]
	mov	DWORD PTR [ecx], edx
$LN33@parse_long:

; 314  : 	if (long_options[match].flag) {

	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	cmp	DWORD PTR [ecx+eax+8], 0
	je	SHORT $LN34@parse_long

; 315  : 		*long_options[match].flag = long_options[match].val;

	mov	edx, DWORD PTR _match$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [ecx+eax+8]
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	edx, DWORD PTR [ecx+edx+12]
	mov	DWORD PTR [eax], edx

; 316  : 		return (0);

	xor	eax, eax
	jmp	SHORT $LN35@parse_long

; 317  : 	} else

	jmp	SHORT $LN35@parse_long
$LN34@parse_long:

; 318  : 		return (long_options[match].val);

	mov	eax, DWORD PTR _match$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _long_options$[ebp]
	mov	eax, DWORD PTR [ecx+eax+12]
$LN35@parse_long:

; 319  : #undef IDENTICAL_INTERPRETATION
; 320  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_parse_long_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
tv206 = -28						; size = 4
tv272 = -24						; size = 4
tv242 = -20						; size = 4
_short_too$ = -16					; size = 4
tv71 = -12						; size = 4
_oli$ = -8						; size = 4
_optchar$ = -4						; size = 4
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_flags$ = 28						; size = 4
_getopt_internal PROC

; 329  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 330  : 	const char *oli;				/* option letter list index */
; 331  : 	int optchar, short_too;
; 332  : 	static int posixly_correct = -1;
; 333  : 
; 334  : 	if (options == NULL)

	cmp	DWORD PTR _options$[ebp], 0
	jne	SHORT $LN2@getopt_int

; 335  : 		return (-1);

	or	eax, -1
	jmp	$LN1@getopt_int
$LN2@getopt_int:

; 336  : 
; 337  : 	/*
; 338  : 	 * XXX Some GNU programs (like cvs) set optind to 0 instead of
; 339  : 	 * XXX using optreset.  Work around this braindamage.
; 340  : 	 */
; 341  : 	if (optind == 0)

	cmp	DWORD PTR _optind, 0
	jne	SHORT $LN3@getopt_int

; 342  : 		optind = optreset = 1;

	mov	DWORD PTR ___mingw_optreset, 1
	mov	eax, DWORD PTR ___mingw_optreset
	mov	DWORD PTR _optind, eax
$LN3@getopt_int:

; 343  : 
; 344  : 	/*
; 345  : 	 * Disable GNU extensions if POSIXLY_CORRECT is set or options
; 346  : 	 * string begins with a '+'.
; 347  : 	 *
; 348  : 	 * CV, 2009-12-14: Check POSIXLY_CORRECT anew if optind == 0 or
; 349  : 	 *                 optreset != 0 for GNU compatibility.
; 350  : 	 */
; 351  : 	if (posixly_correct == -1 || optreset != 0)

	cmp	DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, -1
	je	SHORT $LN5@getopt_int
	cmp	DWORD PTR ___mingw_optreset, 0
	je	SHORT $LN4@getopt_int
$LN5@getopt_int:

; 352  : 		posixly_correct = (getenv("POSIXLY_CORRECT") != NULL);

	push	OFFSET $SG74614
	call	_getenv
	add	esp, 4
	test	eax, eax
	je	SHORT $LN57@getopt_int
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN58@getopt_int
$LN57@getopt_int:
	mov	DWORD PTR tv71[ebp], 0
$LN58@getopt_int:
	mov	ecx, DWORD PTR tv71[ebp]
	mov	DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, ecx
$LN4@getopt_int:

; 353  : 	if (*options == '-')

	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	SHORT $LN6@getopt_int

; 354  : 		flags |= FLAG_ALLARGS;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 2
	mov	DWORD PTR _flags$[ebp], ecx
	jmp	SHORT $LN8@getopt_int
$LN6@getopt_int:

; 355  : 	else if (posixly_correct || *options == '+')

	cmp	DWORD PTR ?posixly_correct@?1??getopt_internal@@9@9, 0
	jne	SHORT $LN9@getopt_int
	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	jne	SHORT $LN8@getopt_int
$LN9@getopt_int:

; 356  : 		flags &= ~FLAG_PERMUTE;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR _flags$[ebp], ecx
$LN8@getopt_int:

; 357  : 	if (*options == '+' || *options == '-')

	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN11@getopt_int
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN10@getopt_int
$LN11@getopt_int:

; 358  : 		options++;

	mov	eax, DWORD PTR _options$[ebp]
	add	eax, 1
	mov	DWORD PTR _options$[ebp], eax
$LN10@getopt_int:

; 359  : 
; 360  : 	optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 361  : 	if (optreset)

	cmp	DWORD PTR ___mingw_optreset, 0
	je	SHORT $start$63

; 362  : 		nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	ecx, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, ecx
$start$63:

; 363  : start:
; 364  : 	if (optreset || !*place) {		/* update scanning pointer */

	cmp	DWORD PTR ___mingw_optreset, 0
	jne	SHORT $LN14@getopt_int
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN27@getopt_int
$LN14@getopt_int:

; 365  : 		optreset = 0;

	mov	DWORD PTR ___mingw_optreset, 0

; 366  : 		if (optind >= nargc) {          /* end of argument vector */

	mov	ecx, DWORD PTR _optind
	cmp	ecx, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN15@getopt_int

; 367  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74625

; 368  : 			if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN16@getopt_int

; 369  : 				/* do permutation, if we have to */
; 370  : 				permute_args(nonopt_start, nonopt_end,

	mov	edx, DWORD PTR _nargv$[ebp]
	push	edx
	mov	eax, DWORD PTR _optind
	push	eax
	mov	ecx, DWORD PTR _nonopt_end
	push	ecx
	mov	edx, DWORD PTR _nonopt_start
	push	edx
	call	_permute_args
	add	esp, 16					; 00000010H

; 371  : 				    optind, nargv);
; 372  : 				optind -= nonopt_end - nonopt_start;

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _optind, ecx

; 373  : 			}

	jmp	SHORT $LN18@getopt_int
$LN16@getopt_int:

; 374  : 			else if (nonopt_start != -1) {

	cmp	DWORD PTR _nonopt_start, -1
	je	SHORT $LN18@getopt_int

; 375  : 				/*
; 376  : 				 * If we skipped non-options, set optind
; 377  : 				 * to the first of them.
; 378  : 				 */
; 379  : 				optind = nonopt_start;

	mov	edx, DWORD PTR _nonopt_start
	mov	DWORD PTR _optind, edx
$LN18@getopt_int:

; 380  : 			}
; 381  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	eax, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, eax

; 382  : 			return (-1);

	or	eax, -1
	jmp	$LN1@getopt_int
$LN15@getopt_int:

; 383  : 		}
; 384  : 		if (*(place = nargv[optind]) != '-' ||

	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _place, eax
	mov	ecx, DWORD PTR _place
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN20@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _place
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	$LN19@getopt_int
	push	45					; 0000002dH
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	$LN19@getopt_int
$LN20@getopt_int:

; 385  : 		    (place[1] == '\0' && strchr(options, '-') == NULL)) {
; 386  : 			place = EMSG;		/* found non-option */

	mov	DWORD PTR _place, OFFSET $SG74631

; 387  : 			if (flags & FLAG_ALLARGS) {

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 2
	je	SHORT $LN21@getopt_int

; 388  : 				/*
; 389  : 				 * GNU extension:
; 390  : 				 * return non-option as argument to option 1
; 391  : 				 */
; 392  : 				optarg = nargv[optind++];

	mov	edx, DWORD PTR _optind
	mov	eax, DWORD PTR _nargv$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _optarg, ecx
	mov	edx, DWORD PTR _optind
	add	edx, 1
	mov	DWORD PTR _optind, edx

; 393  : 				return (INORDER);

	mov	eax, 1
	jmp	$LN1@getopt_int
$LN21@getopt_int:

; 394  : 			}
; 395  : 			if (!(flags & FLAG_PERMUTE)) {

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	jne	SHORT $LN22@getopt_int

; 396  : 				/*
; 397  : 				 * If no permutation wanted, stop parsing
; 398  : 				 * at first non-option.
; 399  : 				 */
; 400  : 				return (-1);

	or	eax, -1
	jmp	$LN1@getopt_int
$LN22@getopt_int:

; 401  : 			}
; 402  : 			/* do permutation */
; 403  : 			if (nonopt_start == -1)

	cmp	DWORD PTR _nonopt_start, -1
	jne	SHORT $LN23@getopt_int

; 404  : 				nonopt_start = optind;

	mov	ecx, DWORD PTR _optind
	mov	DWORD PTR _nonopt_start, ecx
	jmp	SHORT $LN25@getopt_int
$LN23@getopt_int:

; 405  : 			else if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN25@getopt_int

; 406  : 				permute_args(nonopt_start, nonopt_end,

	mov	edx, DWORD PTR _nargv$[ebp]
	push	edx
	mov	eax, DWORD PTR _optind
	push	eax
	mov	ecx, DWORD PTR _nonopt_end
	push	ecx
	mov	edx, DWORD PTR _nonopt_start
	push	edx
	call	_permute_args
	add	esp, 16					; 00000010H

; 407  : 				    optind, nargv);
; 408  : 				nonopt_start = optind -

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _nonopt_start, ecx

; 409  : 				    (nonopt_end - nonopt_start);
; 410  : 				nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
$LN25@getopt_int:

; 411  : 			}
; 412  : 			optind++;

	mov	edx, DWORD PTR _optind
	add	edx, 1
	mov	DWORD PTR _optind, edx

; 413  : 			/* process next argument */
; 414  : 			goto start;

	jmp	$start$63
$LN19@getopt_int:

; 415  : 		}
; 416  : 		if (nonopt_start != -1 && nonopt_end == -1)

	cmp	DWORD PTR _nonopt_start, -1
	je	SHORT $LN26@getopt_int
	cmp	DWORD PTR _nonopt_end, -1
	jne	SHORT $LN26@getopt_int

; 417  : 			nonopt_end = optind;

	mov	eax, DWORD PTR _optind
	mov	DWORD PTR _nonopt_end, eax
$LN26@getopt_int:

; 418  : 
; 419  : 		/*
; 420  : 		 * If we have "-" do nothing, if "--" we are done.
; 421  : 		 */
; 422  : 		if (place[1] != '\0' && *++place == '-' && place[1] == '\0') {

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN27@getopt_int
	mov	ecx, DWORD PTR _place
	add	ecx, 1
	mov	DWORD PTR _place, ecx
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 45					; 0000002dH
	jne	$LN27@getopt_int
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN27@getopt_int

; 423  : 			optind++;

	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx

; 424  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74639

; 425  : 			/*
; 426  : 			 * We found an option (--), so if we skipped
; 427  : 			 * non-options, we have to permute.
; 428  : 			 */
; 429  : 			if (nonopt_end != -1) {

	cmp	DWORD PTR _nonopt_end, -1
	je	SHORT $LN28@getopt_int

; 430  : 				permute_args(nonopt_start, nonopt_end,

	mov	edx, DWORD PTR _nargv$[ebp]
	push	edx
	mov	eax, DWORD PTR _optind
	push	eax
	mov	ecx, DWORD PTR _nonopt_end
	push	ecx
	mov	edx, DWORD PTR _nonopt_start
	push	edx
	call	_permute_args
	add	esp, 16					; 00000010H

; 431  : 				    optind, nargv);
; 432  : 				optind -= nonopt_end - nonopt_start;

	mov	eax, DWORD PTR _nonopt_end
	sub	eax, DWORD PTR _nonopt_start
	mov	ecx, DWORD PTR _optind
	sub	ecx, eax
	mov	DWORD PTR _optind, ecx
$LN28@getopt_int:

; 433  : 			}
; 434  : 			nonopt_start = nonopt_end = -1;

	mov	DWORD PTR _nonopt_end, -1
	mov	edx, DWORD PTR _nonopt_end
	mov	DWORD PTR _nonopt_start, edx

; 435  : 			return (-1);

	or	eax, -1
	jmp	$LN1@getopt_int
$LN27@getopt_int:

; 436  : 		}
; 437  : 	}
; 438  : 
; 439  : 	/*
; 440  : 	 * Check long options if:
; 441  : 	 *  1) we were passed some
; 442  : 	 *  2) the arg is not just "-"
; 443  : 	 *  3) either the arg starts with -- we are getopt_long_only()
; 444  : 	 */
; 445  : 	if (long_options != NULL && place != nargv[optind] &&

	cmp	DWORD PTR _long_options$[ebp], 0
	je	$LN34@getopt_int
	mov	eax, DWORD PTR _optind
	mov	ecx, DWORD PTR _nargv$[ebp]
	mov	edx, DWORD PTR _place
	cmp	edx, DWORD PTR [ecx+eax*4]
	je	$LN34@getopt_int
	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	je	SHORT $LN30@getopt_int
	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 4
	je	$LN34@getopt_int
$LN30@getopt_int:

; 446  : 	    (*place == '-' || (flags & FLAG_LONGONLY))) {
; 447  : 		short_too = 0;

	mov	DWORD PTR _short_too$[ebp], 0

; 448  : 		if (*place == '-')

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN31@getopt_int

; 449  : 			place++;		/* --foo long option */

	mov	edx, DWORD PTR _place
	add	edx, 1
	mov	DWORD PTR _place, edx
	jmp	SHORT $LN33@getopt_int
$LN31@getopt_int:

; 450  : 		else if (*place != ':' && strchr(options, *place) != NULL)

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN33@getopt_int
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _options$[ebp]
	push	ecx
	call	_strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN33@getopt_int

; 451  : 			short_too = 1;		/* could be short option too */

	mov	DWORD PTR _short_too$[ebp], 1
$LN33@getopt_int:

; 452  : 
; 453  : 		optchar = parse_long_options(nargv, options, long_options,

	mov	edx, DWORD PTR _short_too$[ebp]
	push	edx
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _long_options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	call	_parse_long_options
	add	esp, 20					; 00000014H
	mov	DWORD PTR _optchar$[ebp], eax

; 454  : 		    idx, short_too);
; 455  : 		if (optchar != -1) {

	cmp	DWORD PTR _optchar$[ebp], -1
	je	SHORT $LN34@getopt_int

; 456  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74647

; 457  : 			return (optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	jmp	$LN1@getopt_int
$LN34@getopt_int:

; 458  : 		}
; 459  : 	}
; 460  : 
; 461  : 	if ((optchar = (int)*place++) == (int)':' ||
; 462  : 	    (optchar == (int)'-' && *place != '\0') ||

	mov	ecx, DWORD PTR _place
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR _optchar$[ebp], edx
	mov	eax, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR tv206[ebp], eax
	mov	ecx, DWORD PTR _place
	add	ecx, 1
	mov	DWORD PTR _place, ecx
	cmp	DWORD PTR tv206[ebp], 58		; 0000003aH
	je	SHORT $LN36@getopt_int
	cmp	DWORD PTR _optchar$[ebp], 45		; 0000002dH
	jne	SHORT $LN37@getopt_int
	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN36@getopt_int
$LN37@getopt_int:
	mov	ecx, DWORD PTR _optchar$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _oli$[ebp], eax
	cmp	DWORD PTR _oli$[ebp], 0
	jne	SHORT $LN35@getopt_int
$LN36@getopt_int:

; 463  : 	    (oli = strchr(options, optchar)) == NULL) {
; 464  : 		/*
; 465  : 		 * If the user specified "-" and  '-' isn't listed in
; 466  : 		 * options, return -1 (non-option) as per POSIX.
; 467  : 		 * Otherwise, it is an unknown option character (or ':').
; 468  : 		 */
; 469  : 		if (optchar == (int)'-' && *place == '\0')

	cmp	DWORD PTR _optchar$[ebp], 45		; 0000002dH
	jne	SHORT $LN38@getopt_int
	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN38@getopt_int

; 470  : 			return (-1);

	or	eax, -1
	jmp	$LN1@getopt_int
$LN38@getopt_int:

; 471  : 		if (!*place)

	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN39@getopt_int

; 472  : 			++optind;

	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx
$LN39@getopt_int:

; 473  : 		if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN40@getopt_int
	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN40@getopt_int

; 474  : 			warnx(illoptchar, optchar);

	mov	ecx, DWORD PTR _optchar$[ebp]
	push	ecx
	push	OFFSET _illoptchar
	call	_warnx
	add	esp, 8
$LN40@getopt_int:

; 475  : 		optopt = optchar;

	mov	edx, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, edx

; 476  : 		return (BADCH);

	mov	eax, 63					; 0000003fH
	jmp	$LN1@getopt_int
$LN35@getopt_int:

; 477  : 	}
; 478  : 	if (long_options != NULL && optchar == 'W' && oli[1] == ';') {

	cmp	DWORD PTR _long_options$[ebp], 0
	je	$LN41@getopt_int
	cmp	DWORD PTR _optchar$[ebp], 87		; 00000057H
	jne	$LN41@getopt_int
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _oli$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 59					; 0000003bH
	jne	$LN41@getopt_int

; 479  : 		/* -W long-option */
; 480  : 		if (*place)			/* no space */

	mov	eax, DWORD PTR _place
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN42@getopt_int

; 481  : 			/* NOTHING */;

	jmp	$LN45@getopt_int
$LN42@getopt_int:

; 482  : 		else if (++optind >= nargc) {	/* no arg */

	mov	edx, DWORD PTR _optind
	add	edx, 1
	mov	DWORD PTR _optind, edx
	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN44@getopt_int

; 483  : 			place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74659

; 484  : 			if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN46@getopt_int
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN46@getopt_int

; 485  : 				warnx(recargchar, optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	push	eax
	push	OFFSET _recargchar
	call	_warnx
	add	esp, 8
$LN46@getopt_int:

; 486  : 			optopt = optchar;

	mov	ecx, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, ecx

; 487  : 			return (BADARG);

	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN59@getopt_int
	mov	DWORD PTR tv242[ebp], 58		; 0000003aH
	jmp	SHORT $LN60@getopt_int
$LN59@getopt_int:
	mov	DWORD PTR tv242[ebp], 63		; 0000003fH
$LN60@getopt_int:
	mov	eax, DWORD PTR tv242[ebp]
	jmp	$LN1@getopt_int

; 488  : 		} else				/* white space */

	jmp	SHORT $LN45@getopt_int
$LN44@getopt_int:

; 489  : 			place = nargv[optind];

	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _place, eax
$LN45@getopt_int:

; 490  : 		optchar = parse_long_options(nargv, options, long_options,

	push	0
	mov	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _long_options$[ebp]
	push	edx
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nargv$[ebp]
	push	ecx
	call	_parse_long_options
	add	esp, 20					; 00000014H
	mov	DWORD PTR _optchar$[ebp], eax

; 491  : 		    idx, 0);
; 492  : 		place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74661

; 493  : 		return (optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	jmp	$LN1@getopt_int
$LN41@getopt_int:

; 494  : 	}
; 495  : 	if (*++oli != ':') {			/* doesn't take argument */

	mov	edx, DWORD PTR _oli$[ebp]
	add	edx, 1
	mov	DWORD PTR _oli$[ebp], edx
	mov	eax, DWORD PTR _oli$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 58					; 0000003aH
	je	SHORT $LN47@getopt_int

; 496  : 		if (!*place)

	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN49@getopt_int

; 497  : 			++optind;

	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx
$LN49@getopt_int:

; 498  : 	} else {				/* takes (optional) argument */

	jmp	$LN48@getopt_int
$LN47@getopt_int:

; 499  : 		optarg = NULL;

	mov	DWORD PTR _optarg, 0

; 500  : 		if (*place)			/* no white space */

	mov	edx, DWORD PTR _place
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN50@getopt_int

; 501  : 			optarg = place;

	mov	ecx, DWORD PTR _place
	mov	DWORD PTR _optarg, ecx
	jmp	$LN54@getopt_int
$LN50@getopt_int:

; 502  : 		else if (oli[1] != ':') {	/* arg not optional */

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _oli$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 58					; 0000003aH
	je	$LN54@getopt_int

; 503  : 			if (++optind >= nargc) {	/* no arg */

	mov	edx, DWORD PTR _optind
	add	edx, 1
	mov	DWORD PTR _optind, edx
	mov	eax, DWORD PTR _optind
	cmp	eax, DWORD PTR _nargc$[ebp]
	jl	SHORT $LN53@getopt_int

; 504  : 				place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74670

; 505  : 				if (PRINT_ERROR)

	cmp	DWORD PTR _opterr, 0
	je	SHORT $LN55@getopt_int
	mov	ecx, DWORD PTR _options$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 58					; 0000003aH
	je	SHORT $LN55@getopt_int

; 506  : 					warnx(recargchar, optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
	push	eax
	push	OFFSET _recargchar
	call	_warnx
	add	esp, 8
$LN55@getopt_int:

; 507  : 				optopt = optchar;

	mov	ecx, DWORD PTR _optchar$[ebp]
	mov	DWORD PTR _optopt, ecx

; 508  : 				return (BADARG);

	mov	edx, DWORD PTR _options$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	jne	SHORT $LN61@getopt_int
	mov	DWORD PTR tv272[ebp], 58		; 0000003aH
	jmp	SHORT $LN62@getopt_int
$LN61@getopt_int:
	mov	DWORD PTR tv272[ebp], 63		; 0000003fH
$LN62@getopt_int:
	mov	eax, DWORD PTR tv272[ebp]
	jmp	SHORT $LN1@getopt_int

; 509  : 			} else

	jmp	SHORT $LN54@getopt_int
$LN53@getopt_int:

; 510  : 				optarg = nargv[optind];

	mov	ecx, DWORD PTR _optind
	mov	edx, DWORD PTR _nargv$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _optarg, eax
$LN54@getopt_int:

; 511  : 		}
; 512  : 		place = EMSG;

	mov	DWORD PTR _place, OFFSET $SG74672

; 513  : 		++optind;

	mov	ecx, DWORD PTR _optind
	add	ecx, 1
	mov	DWORD PTR _optind, ecx
$LN48@getopt_int:

; 514  : 	}
; 515  : 	/* dump back option letter */
; 516  : 	return (optchar);

	mov	eax, DWORD PTR _optchar$[ebp]
$LN1@getopt_int:

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 844  :     }

	mov	esp, ebp
	pop	ebp
	ret	0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vfprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__ArgList$ = 16						; size = 4
_vfprintf PROC						; COMDAT

; 658  :     {

	push	ebp
	mov	ebp, esp

; 659  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Stream$[ebp]
	push	edx
	call	__vfprintf_l
	add	esp, 16					; 00000010H

; 660  :     }

	pop	ebp
	ret	0
_vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	___stdio_common_vfprintf
	add	esp, 24					; 00000018H

; 646  :     }

	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long_only PROC

; 562  : {

	push	ebp
	mov	ebp, esp

; 563  : 
; 564  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,

	push	5
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _long_options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nargc$[ebp]
	push	ecx
	call	_getopt_internal
	add	esp, 24					; 00000018H

; 565  : 	    FLAG_PERMUTE|FLAG_LONGONLY));
; 566  : }

	pop	ebp
	ret	0
_getopt_long_only ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_long_options$ = 20					; size = 4
_idx$ = 24						; size = 4
_getopt_long PROC

; 549  : {

	push	ebp
	mov	ebp, esp

; 550  : 
; 551  : 	return (getopt_internal(nargc, nargv, options, long_options, idx,

	push	1
	mov	eax, DWORD PTR _idx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _long_options$[ebp]
	push	ecx
	mov	edx, DWORD PTR _options$[ebp]
	push	edx
	mov	eax, DWORD PTR _nargv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nargc$[ebp]
	push	ecx
	call	_getopt_internal
	add	esp, 24					; 00000018H

; 552  : 	    FLAG_PERMUTE));
; 553  : }

	pop	ebp
	ret	0
_getopt_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Users\Achmed\Git_Repos_AH1\My_First_C_Program\getopt.c
_TEXT	SEGMENT
_nargc$ = 8						; size = 4
_nargv$ = 12						; size = 4
_options$ = 16						; size = 4
_getopt	PROC

; 528  : {

	push	ebp
	mov	ebp, esp

; 529  : 
; 530  : 	/*
; 531  : 	 * We don't pass FLAG_PERMUTE to getopt_internal() since
; 532  : 	 * the BSD getopt(3) (unlike GNU) has never done this.
; 533  : 	 *
; 534  : 	 * Furthermore, since many privileged programs call getopt()
; 535  : 	 * before dropping privileges it makes sense to keep things
; 536  : 	 * as simple (and bug-free) as possible.
; 537  : 	 */
; 538  : 	return (getopt_internal(nargc, nargv, options, NULL, NULL, 0));

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _options$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nargv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nargc$[ebp]
	push	edx
	call	_getopt_internal
	add	esp, 24					; 00000018H

; 539  : }

	pop	ebp
	ret	0
_getopt	ENDP
_TEXT	ENDS
END
